
Group: NOT DEFINED
Name: A
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: ampere, electric current

Group: NOT DEFINED
Name: C
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: coulumb, electric charge or quantity of electircity

Group: NOT DEFINED
Name: F
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: farad, electric capacitance

Group: NOT DEFINED
Name: Gy
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: gray, absorbed dose of ionizing radiation

Group: NOT DEFINED
Name: H
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: henry, inductance

Group: NOT DEFINED
Name: Hz
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: hertz, frequency

Group: NOT DEFINED
Name: J
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: jule, energy or work or heat

Group: NOT DEFINED
Name: K
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: kelvin, temperature

Group: NOT DEFINED
Name: N
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: newton, force and weight

Group: NOT DEFINED
Name: Ohm
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: ohm, electric impedance or resistance or reactance

Group: NOT DEFINED
Name: Pa
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: pascal, pressure stress

Group: NOT DEFINED
Name: S
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: siemens, electric conductance

Group: NOT DEFINED
Name: T
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: tesla, magnetic flux strength

Group: NOT DEFINED
Name: V
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: volt, voltage or electromotive force

Group: NOT DEFINED
Name: W
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: watt, power or radiant flux

Group: NOT DEFINED
Name: Wb
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: weber, magnetic flux

Group: NOT DEFINED
Name: cd
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: candela, luminescent intensity

Group: NOT DEFINED
Name: kat
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: katal, catalytic activity

Group: NOT DEFINED
Name: kg
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: kilogram, mass

Group: NOT DEFINED
Name: lx
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: lux, illuminance

Group: NOT DEFINED
Name: m
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: metre, length

Group: NOT DEFINED
Name: mol
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: mole, amount of substance

Group: NOT DEFINED
Name: rad
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: radian, angle

Group: NOT DEFINED
Name: s
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: second, time

Group: NOT DEFINED
Name: sr
Type: variable
This variable is locked: cannot be changed by user
Help: Created automatically when measurementUnit group is loaded: steradian, solid angle

Group: arithmetic
Name: *
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Complex Interval)
Supported right domain: (Complex Interval)
Priority: 10, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a * b return a multiplied by b.
It works on Kaucher and complex arithmetic. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(6_9)*(1_3) == (6_27)

Group: arithmetic
Name: +
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Interval)
Supported right domain: (Interval)
Priority: 9, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a + b  return a summed to b.
It adds the a and b intervals. It works on complex intervals. If the input are literals they are joined. However if more than two literals need to be join it is more efficen use literalJoin function. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(6_9)+(1_3) == (7_12)
('hel')+('lo') == ('hello')

Group: arithmetic
Name: +
Type: prefix function
Number of args: at least 1
Supported domain: (Complex Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: + a returns a.
It just does nothing. It is the prefix function corresponding to addition.
Examples: 
+(1, 2, 3) == 1, 2, 3

Group: arithmetic
Name: -
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Complex Interval)
Supported right domain: (Complex Interval)
Priority: 9, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a - b return a subtacted by b.
It subtracts b from a. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(6_9)-(1_3) == (3_8)

Group: arithmetic
Name: -
Type: prefix function
Number of args: 1
Supported domain: (Complex Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: - a returns the opposite value to a: -a.
It negates the a interval or list of intervals. Please note the precedence for prefix function (like -) is higher than infix function therefore -2^2 is computed like (-2)^2, which gives 4.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
-((1%4)) == -1%4
;-2^2 == 4
;0-2^2 == -4

Group: arithmetic
Name: /
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Complex Interval)
Supported right domain: (Not Literal or Interval 0.0)
Priority: 10, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a / b divides a by b.
The b interval should not contain the 0. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(6_9)/(1_3) == (2_9)

Group: arithmetic
Name: invert
Type: prefix function
Number of args: 1
Supported domain: (Not Literal or Interval 0.0)
Automatically extends to list
This function is locked: cannot be changed by user
Help: invert a return the a inverted interval (1/a).
It is faster than executing (1/a) and works on complex intervals. a should not contain 0.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
invert(2, 4) == 0.5, 0.25

Group: calculus
Name: calculusDerivate
Type: prefix function
Number of args: at least 2
Supported domain: (Prefix Function with at least 1 arguments,Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: calculusDerivate ('f', x0, x1, .., xn ) computes the incremental ratio of the function f in the intervals xileft, xiright.
For the input variable expressed in terms of list of intervals the derivate is compute with higher order: calculusDerivate ($sin, {1_1.1,1.1_1.2}) computes the second order derivate of function sin in the pont 1.1. If the input contains several set of point the derivate is computed for each one.
Examples: 
calculusDerivate($sin, -0.0001_0.0001) == 1
calculusDerivate($sin, 0+-0.0001, (PI/2)%0.1) == 1,0
calculusDerivate(defineLambdaFunction('2*$x+4*$y'),1%0.1,1, 1,1%0.1) == 2,4
calculusDerivate(defineLambdaFunction('2*$x*$y'),2%0.1,2%0.1, 2%0.1,2, 2,2%0.1 ) == 2,4,4
calculusDerivate(defineLambdaFunction('$x^2'),{1_1.1, 1.1_1.2} ) == 2
calculusDerivate(defineLambdaFunction('$x^3'),{1_1.1, 1.1_1.2} ) == 6*1.1

Group: calculus
Name: calculusFindAbsolute
Type: prefix function
Number of args: at least 4
Supported domain: (Prefix Function with at least 1 arguments,Prefix Function with at least 1 arguments or Infix Function with at least 1 left arguments and with at least 1 right arguments,Integer Interval and Point Interval and Positive Interval,Proper Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: calculusFindAbsolute ($f, 'compareFunc', npoints, int0, int1, .., intn ) split each input interval (int1 .. intn) in the given number of points (npoints) linearly spaced then compute f in each point and returns the xi value where f(xi) 'compareFunction' xj (i != j) is always true.
This test is not able to find the exact x-point, but can be used as a starting point for optimization function.
Examples: 
calculusFindAbsolute($sin, '>', 101, 0_PI) == PI/2
calculusFindAbsolute($cos, '>', 100, 0_PI) == 0
calculusFindAbsolute(defineLambdaFunction('(10-($x-1)^2)+(10-($y-2)^2)'),'>',21,-10_10,-10_10) == 1,2
calculusFindAbsolute($sin, '<', 101, 0_2*PI) == PI+PI/2
calculusFindAbsolute($cos, '<', 100, 0_PI) == PI
calculusFindAbsolute(defineLambdaFunction('(($x-1)^2)+(($y-2)^2)'), '<',21,-10_10,-10_10) == 1,2

Group: calculus
Name: calculusFindMatch
Type: prefix function
Number of args: at least 4
Supported domain: (Prefix Function with at least 1 arguments,Prefix Function with at least 1 arguments or Infix Function with at least 1 left arguments and with at least 1 right arguments,Integer Interval and Point Interval and Positive Interval,Proper Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: calculusFindMatch ($f, 'compareFunc', npoints, int0, int1, .., intn ) split each input interval (int1 .. intn) in the given number of points (npoints) linearly spaced then compute f in each point and check if the test function applied at that value returns true (storing that x value).
This test is not able to find the exact x-point, but can be used as a starting point for optimization function.
Examples: 
; calculusFindMatch($sin, defineLambdaFunction('$x << -0.004_0.004'), 1001, -1_7) << (0, PI, 2*PI)+-0.05 == true, true, true

Group: calculus
Name: calculusFindRelative
Type: prefix function
Number of args: at least 4
Supported domain: (Prefix Function with at least 1 arguments,Prefix Function with at least 1 arguments or Infix Function with at least 1 left arguments and with at least 1 right arguments,Integer Interval and Point Interval and Positive Interval,Proper Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: calculusFindRelative ($f, 'compareFunc', npoints, int0, int1, .., intn ) split each input interval (int1 .. intn) in the given number of points (npoints) linearly spaced then compute f in each point and returns the xi values where f(xi) 'compareFunction' xj for all the xj points around xi is true.
That comparison is not made at the extremes of the interval. This test is not able to find the exact x-point, but can be used as a starting point for optimization function.
Examples: 
calculusFindRelative(defineLambdaFunction('($x-1)*($x-2)*($x-3)'), '>', 10001, 0_4) == ($f1, $x)='(x-2)*(x-3)+(x-1)*(x-3)+(x-1)*(x-2)';equationFindRoot($f1, 1_2, 0)
calculusFindRelative(defineLambdaFunction('($x-1)*($x-2)*($x-3)'), '<', 10001, 0_4) == ($f1, $x)='(x-2)*(x-3)+(x-1)*(x-3)+(x-1)*(x-2)';equationFindRoot($f1, 2_3, 0)

Group: calculus
Name: calculusIntegrate
Parameter: maxDeep
Value: 12
Expected Input: Requires integer value between 1 and 20
Default: 12
Help: The maximum deep (2^maxDeep) to explore for functin characteristics.

Group: calculus
Name: calculusIntegrate
Parameter: minDeep
Value: 3
Expected Input: Requires integer value between 1 and 10
Default: 3
Help: The minimum deep (2^minDeep) to explore for functin characteristics.

Group: calculus
Name: calculusIntegrate
Parameter: tolerance
Value: 0.002
Expected Input: Requires double value between 0.0 and 1.0
Default: 0.002
Help: The maximum allowed tolerance in the trapezoid, unless maxDeep is reached. Default was found to have 3 decimal digit accuracy on sin x integrate between 0 and pi.

Group: calculus
Name: calculusIntegrate
Type: prefix function
Number of args: at least 2
Supported domain: (Prefix Function with at least 1 arguments,Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: calculusIntegrate ('f', x0, x1, calculusIntegrate, xn) integrates the function f(x0, x1, calculusIntegrate, xn) on the input parameter provided as real intervals.
It is possible to integrate on several variables. The interval is split in sub intervals and integrated. The sub intervals are defined in order to get a good accuracy. If the function is stable few intervals are used. It is usually faster and with similar accuracy of a standard IntegrateUniform function with 100 intervals. It is possible to provide several interval input sets to compute the integral on several variables simultaneously. It possible to provide the some setting to the function with the function systemSetupParameters ($calculusIntegrate, mindeep, maxdeep, tol): 2^mindeep is the minimum number of interval to set (default is 2^3=8 intervals) the smaller the faster works for simple function however with a too smal set of itnervals a functin may seem stable while it is not. 2^maxdeep is the maximum number of itnervals (default is 2^12=4048), the higher the higher is the accuracy however the computational and memory time will rise exponentially. accuracy is how the trapezoid found looks good to calculate its area (default is .2/100=0.2% to get 3 digits in sin integration). A smaller value will require more intervals as far as 2^maxdeep is reached.
Examples: 
calculusIntegrate($sin, 0_PI) == 2
calculusIntegrate(defineLambdaFunction('$x+$y'),0_2,1_4) == 21

Group: calculus
Name: calculusIntegrateUniform
Type: prefix function
Number of args: 3
Supported domain: (Prefix Function with 1 arguments,Point Interval and Integer Interval and Positive Interval,Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: calculusIntegrateUniform ('f', nofsectors, interval) integrates the function f in the given interval split in the required number of sectors and evaluating the function in the middle of them.
The interval is split in the given number of intervals and the rectangular areas are computed and summed. This function is kept for partial comatibility versus previous versions. For the integral function, use Integrate.It is possible to apply this function to multiple arguments just adding several intervals as last parameter. 
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
calculusIntegrateUniform($sin, 100, 0_PI) == 2

Group: calculus
Name: calculusIntegrateUniformFunction
Type: prefix function
Number of args: 3
Supported domain: (Prefix Function with 1 arguments,Point Interval and Integer Interval and Positive Interval,Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: calculusIntegrateUniformFunction ('f', nofsectors, interval) returns the integrate function computed in the give interval split in the given sectors.
 Basically calculusIntegrateUniformFunction ($f, 100, 0_x) is a very efficient shortcut for the follwing expression ($integratef, $x) = 'integrate ($f, 100, 0_x)' and then computing intefratef in 0_100.It is possible to apply this function to multiple arguments just adding several intervals as last parameter. 
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
calculusIntegrateUniformFunction(($f, $x)='x', 10, 0_10) == listLinear(10, 1_10)#1, (listLinear(10, 1_10)#1 )^2/2

Group: calculus
Name: calculusJacobian
Type: prefix function
Number of args: 2
Supported domain: ({Interval List of [Prefix Function with at least 1 arguments]},{Interval List of [Real Interval]})
Does not extend to list
This function is locked: cannot be changed by user
Help: calculusJacobian ({'f1', .., 'fn'},{ x1, .., xn }) given n functions of n arguments (x1, .., xn) and n initial intervals computes the Jacobian in the given intervals.
Examples: 
calculusJacobian({defineLambdaFunction ('2*$x+$y'), defineLambdaFunction ('$x+4*$y')},{(0,1)+-0.01}) == (2,1,1,4)#2

Group: calculus
Name: calculusSeriesProduct
Type: prefix function
Number of args: 2
Supported domain: (Prefix Function with 1 arguments,Integer Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: calculusSeriesProduct ('f', begin_end) compute f(begin) * calculusSeriesProduct * f(end).
It can be used to evaluate productories.It is possible to apply this function to multiple arguments just adding several intervals as last parameter. 
Examples: 
calculusSeriesProduct(defineLambdaFunction('$x'), 1_(1 .. 4)) == 1, 2, 6, 24

Group: calculus
Name: calculusSeriesSum
Type: prefix function
Number of args: 2
Supported domain: (Prefix Function with 1 arguments,Integer Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: calculusSeriesSum ('f', begin_end) compute f(begin)+ calculusSeriesSum + f(end).
It can be used to compute summatories.It is possible to apply this function to multiple arguments just adding several intervals as last parameter. 
Examples: 
calculusSeriesSum(defineLambdaFunction('2*$x+1'), 0_(1 .. 5)) == (2 .. 6)^2

Group: compare
Name: !=
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Interval)
Supported right domain: (Interval)
Priority: 7, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a != b checks if a is different from b. It checks if for every points of the first interval does not exist an equal point in the second and returns true, if juse some does not exists it return trueFalse, if none it returns false. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(6_7)!=(4_5) == (1)
(6_7)!=(7_9) == (0_1)
(1_3)!=(2_4) == (0_1)
(3_4)!=(3_4) == (0)
(1+I)!=(I+1) == (0)
('abl')!=('abl') == (0)

Group: compare
Name: <
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Real Interval and Proper Interval)
Supported right domain: (Real Interval and Proper Interval)
Priority: 8, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a < b check is a is less than be.
It checks if for every points of the first interval exists a smaller point in the second and returns true, if just some is smaller it returns trueFlase, if none it returns false. It returns 0 if the preposition is not verified for every point of the first interval, 1 for it is always verified, 0_1 if it is verified only for some points. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(6_7)<(4_5) == (0)
(6_7)<(7_8) == (0_1)
(1)<(2_4) == (1)
(3_4)<(-3_-2) == (0)

Group: compare
Name: <=
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Real Interval and Proper Interval)
Supported right domain: (Real Interval and Proper Interval)
Priority: 8, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a <= b checks if a is less or equal than b.
It checks if for every points of the first interval exists a smaller or equal point in the second and returns true, if just some are smaller or equal it returns trueFalse, if none it returns false. It returns 0 if the preposition is not verified for every point of the first interval, 1 for it is always verified, 0_1 if it is verified only for some points. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(6_7)<=(4_5) == (0)
(6_7)<=(7_8) == (1)
(1_3)<=(2_4) == (0_1)
(3_4)<=(-3_-2) == (0)

Group: compare
Name: ==
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Interval)
Supported right domain: (Interval)
Priority: 7, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a == b check if a equals to b.
It return true if a and b are equals, trueFalse if they have some point in common, false if they have none. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(6_7)==(4_5) == (0)
(6_7)==(7_9) == (0_1)
(1_3)==(2_4) == (0_1)
(3_4)==(3_4) == (1)
(1+I)==(I+1) == (1)
('abl')==('abl') == (1)

Group: compare
Name: >
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Real Interval and Proper Interval)
Supported right domain: (Real Interval and Proper Interval)
Priority: 8, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a > b check if a is greater than b.
It checks if for every points of the first interval exists an greater point in the second and returns true, if only some is greater return trueFalse, if none returns false. It returns 0 if the preposition is not verified for every point of the first interval, 1 for it is always verified, 0_1 if it is verified only for some points. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(6_7)>(4_5) == (1)
(6_7)>(5_6) == (0_1)
(1_2)>(2_4) == (0)
(3_4)>(-3_-2) == (1)

Group: compare
Name: >=
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Real Interval and Proper Interval)
Supported right domain: (Real Interval and Proper Interval)
Priority: 8, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a >= b check if a >= b.
It checks if for every points of the first interval exists a greater or equal point in the second and returns true, if some it return trueFalse, if none it returns false. It returns 0 if the preposition is not verified for every point of the first interval, 1 for it is always verified, 0_1 if it is verified only for some points. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(6_7)>=(4_5) == (1)
(6_7)>=(5_6) == (1)
(1_2)>=(2_4) == (0_1)
(-3_-2)>=(3_4) == (0)

Group: complex
Name: +|
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Real Interval)
Supported right domain: (Real Interval)
Priority: 9, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a +| b return a + I * b.
It is a shortcut and more efficient way to create complex number (than use explicitly the immaginary unit I). It expects two real intervals. a +| b is evaluated much faster than a + I * b. However for more complex purpose it is useful the imaginary constant I. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(6_7)+|(4_5) == (6_7+I*4_5)

Group: complex
Name: I
Type: variable
This variable is locked: cannot be changed by user
Help: The imaginary constant so that I*I = -1.

Group: complex
Name: abs
Type: prefix function
Number of args: 1
Supported domain: (Complex Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: abs a return the module of complex interval a.
It compute the absolute value of an interval. It is extended to directed interval and need to be verified for not proper interval.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
abs(-10_10) == 0_10
abs(-10_-5) == 5_10
abs(10_15) == 10_15
abs(10_-10) == 10_0
abs(-5_-10) == 10_5
abs(15_10) == 15_10
abs(4+3*I) == 5
abs(3*I) == 3

Group: complex
Name: complexArg
Type: prefix function
Number of args: 1
Supported domain: (Complex Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: complexArg a returns the phase of complex interval a.
It compute the phase of a complex interval. It is extended to directed interval and need to be verified for not proper interval.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
complexArg(1+I) == PI/4
complexArg(1-I) == -PI/4
complexArg(-1-I) == -3*PI/4
complexArg(-1+I) == 3*PI/4

Group: complex
Name: complexConjugate
Type: prefix function
Number of args: 1
Supported domain: (Complex Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: complexConjugate (a + I *b) returns (a -  I *b).
It creates a complex number conjugate of the given one.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
complexConjugate(1+|2) == 1-2*I
complexConjugate(1) == 1
complexConjugate(2*I) == -2*I

Group: complex
Name: complexImaginaryPart
Type: prefix function
Number of args: 1
Supported domain: (Complex Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: complexImaginaryPart (a+I*b) returns b.
It gets the imaginary part of a complex interval.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
complexImaginaryPart(1+|2) == 2

Group: complex
Name: complexPower
Type: prefix function
Number of args: 2
Supported domain: (Complex Interval,Integer Interval and Positive Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: complexPower (complexNumber, n) computes the n-th power of the given complexNumber.
It uses the polar form to compute all the roots which may increase the size of the resulting interval.
This is a system defined function as per the folowing ICE expression: abs(c)^n*exp(I*complexArg(c)*n)
Examples: 
complexPower(I, 2) == -1

Group: complex
Name: complexRealPart
Type: prefix function
Number of args: 1
Supported domain: (Complex Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: complexRealPart (a+I*b) returns a.
It gets the real part of a complex interval.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
complexRealPart(1+|2) == 1

Group: complex
Name: complexRoot
Type: prefix function
Number of args: 2
Supported domain: (Complex Interval,Integer Interval and Positive Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: complexRoot (complexNumber, n) computes the n-th roots of the given complexNumber.
It provides all the solutions available. It uses the polar form to compute all the roots which may increase the result of the ending intervals.
This is a system defined function as per the folowing ICE expression: abs(c)^(1/n)*exp(I*(complexArg(c)+(1 .. n)*2*PI)/n)
Examples: 
complexRoot(1, 2) == -1, 1

Group: conditional
Name: conditionalALLFUNCTIONS
Parameter: maxIteration
Value: 300
Expected Input: Requires integer value between 1 and 1000
Default: 300
Help: The maximum number of iterations, above which the conditional function stops

Group: conditional
Name: conditionalDoWhile
Type: prefix function
Number of args: 3
Supported domain: (Interval,Prefix Function with 1 arguments,Real Interval or Prefix Function with 1 arguments)
Does not extend to list
This function is locked: cannot be changed by user
Help: conditionalDoWhile (initialValue, $calculations, $condition) executes conditionalDoWhile (argument=initialValue, argument=calculations(argument), condition(argument)) while condition(argument) is ture.
It set internal variable argument to initialValue, then executes argument = calculation(argument) while condition(argument) returns true. Note if 'condition' is false the calculation is executed one time. calculation must be a prefix function while condition can be a prefix function or an interval.In ICE all the inputs of a function are evaluated before calling it. That does not help in loops where the loop condition would never be checked again neither in conditional statements where all the options would be evaluated not only the correct one. However all the conditional expression accepts prefix function name or interval as arguments. A prefix function has the advantage to be evaluable later and several  evaluations may provide different results. All the conditinal functions has aa interval interval (called argumen) which is set to the value of the first argument. Then it is used as input to the check prefix function or as input to the computation prefix functions whose result is again stored in that argument. If the condition is an interval it is just verified the argument lies in it, if it is a prefix function it is evaluate at argument and its result is returned.
Examples: 
conditionalDoWhile(0,defineLambdaFunction('$x+1'), defineLambdaFunction('$x<5')) == 5
conditionalDoWhile(5,defineLambdaFunction('$x+1'), defineLambdaFunction('$x<5')) == 6

Group: conditional
Name: conditionalFor
Type: prefix function
Number of args: 5
Supported domain: (Interval,Literal,Interval,Interval,Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: conditionalFor (start1, $condition, $increment, start2, $calculations)  executes ('argument1=start, condition(argument1), argument1 = increment(argument1), argument2, argument2 = calculations(argument1, argument2)).
The expression 'start' is evaluated then while the 'condition(argument)' is true, the argument2=calculation(argument, argument2) is computed, then the argumetn=increment(argument) and again the condition. The result of last argument2 is returned.In ICE all the inputs of a function are evaluated before calling it. That does not help in loops where the loop condition would never be checked again neither in conditional statements where all the options would be evaluated not only the correct one. However all the conditional expression accepts prefix function name or interval as arguments. A prefix function has the advantage to be evaluable later and several  evaluations may provide different results. All the conditinal functions has aa interval interval (called argumen) which is set to the value of the first argument. Then it is used as input to the check prefix function or as input to the computation prefix functions whose result is again stored in that argument. If the condition is an interval it is just verified the argument lies in it, if it is a prefix function it is evaluate at argument and its result is returned.
Examples: 
$a=(1,2,3,4),$b=(5,6,7,8),$c=(0,0,0,0);conditionalFor(0,defineLambdaFunction '$i<4', defineLambdaFunction '$i+1', {c}, defineLambdaFunction '$j ::=($i, (a :: $i) * (b :: $i))') == {a*b}

Group: conditional
Name: conditionalIf
Type: prefix function
Number of args: at least 3
Supported domain: (Interval,Real Interval or Prefix Function with 1 arguments)
Does not extend to list
This function is locked: cannot be changed by user
Help: conditionalIf (argument, condition, retIfTrue, retIfTrueFalse, retIfFalse) evaluate condition(argument) then depending on the logic result returns one of the intervals or prefix function: retIfTrue(argument), retIfTrueFalse(argument), retIfFalse(argument).
If condition is an interval it verifies if interval argument is included in condition. If the return functions are intervals they are returned. retIfTrueFalse, retIfFalse or just retIfFalseIt may miss, however an error will be risen if a condition not available is reached. This function can be used in recursion (only with prefix function as argument) because it would evaluate all its arguments (also the true and false values), therefore the loop would never end.In ICE all the inputs of a function are evaluated before calling it. That does not help in loops where the loop condition would never be checked again neither in conditional statements where all the options would be evaluated not only the correct one. However all the conditional expression accepts prefix function name or interval as arguments. A prefix function has the advantage to be evaluable later and several  evaluations may provide different results. All the conditinal functions has aa interval interval (called argumen) which is set to the value of the first argument. Then it is used as input to the check prefix function or as input to the computation prefix functions whose result is again stored in that argument. If the condition is an interval it is just verified the argument lies in it, if it is a prefix function it is evaluate at argument and its result is returned.
Examples: 
conditionalIf(1, 1_2, 2, 3, 4) == 2
conditionalIf(0,1_2,2,3,4) == 4
conditionalIf(0_1,0.5_2,2,3,4) == 3

Group: conditional
Name: conditionalIfTrue
Type: prefix function
Number of args: 3
Supported domain: (Interval,Interval,Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: conditionalIfTrue (booleanCondition, retIfTrue, retOtherwise) evaluate boolean condition and if it is true then return retIfTrue otherwise it returns retOtherwise.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
conditionalIfTrue(1, 1_2, 2) == 1_2
conditionalIfTrue(0,1_2,2) == 2

Group: conditional
Name: conditionalSwitch
Type: prefix function
Number of args: at least 2
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: conditionalSwitch (value, cond1, val1, .., condn, valn, valDefault) it checks the given value, if it meets cond1(value) it returns val1 and so on, if a valDefalt is left alone (without condition) at the end it is always returned.
If condition is an interval it is verified value is a sub-set of condition. If vali is a prefix function then vali(argument) is returned. If no condition is triggered an exception is rised: to avoid that use a default value. If more then a condition is true, it is returned the value of the first. It is useful to define a function on several domains: ($f, $x) = 'conditionalSwitch (x, 0, 1, defineLambdaFunction('sin $x / $x'))'In ICE all the inputs of a function are evaluated before calling it. That does not help in loops where the loop condition would never be checked again neither in conditional statements where all the options would be evaluated not only the correct one. However all the conditional expression accepts prefix function name or interval as arguments. A prefix function has the advantage to be evaluable later and several  evaluations may provide different results. All the conditinal functions has aa interval interval (called argumen) which is set to the value of the first argument. Then it is used as input to the check prefix function or as input to the computation prefix functions whose result is again stored in that argument. If the condition is an interval it is just verified the argument lies in it, if it is a prefix function it is evaluate at argument and its result is returned.
Examples: 
conditionalSwitch((1, 2_3, false, 0_2, true)) == true

Group: conditional
Name: conditionalWhile
Type: prefix function
Number of args: 3
Supported domain: (Interval,Real Interval or Prefix Function with 1 arguments,Prefix Function with 1 arguments)
Does not extend to list
This function is locked: cannot be changed by user
Help: conditionalWhile (initialValue, $condition, $calculations) exexutes conditionalWhile (argument=initialValue, condition(argument), argument=calculations(argument)) while condition(argument) is true.
It set internal variable arg to initialValue, then executes condition(arg) and whils it is true executes arg = calculation(arg). Note if 'condition' is false the calculation is never executed. calculation must be a prefix function while condition can be a prefix function or an interval.In ICE all the inputs of a function are evaluated before calling it. That does not help in loops where the loop condition would never be checked again neither in conditional statements where all the options would be evaluated not only the correct one. However all the conditional expression accepts prefix function name or interval as arguments. A prefix function has the advantage to be evaluable later and several  evaluations may provide different results. All the conditinal functions has aa interval interval (called argumen) which is set to the value of the first argument. Then it is used as input to the check prefix function or as input to the computation prefix functions whose result is again stored in that argument. If the condition is an interval it is just verified the argument lies in it, if it is a prefix function it is evaluate at argument and its result is returned.
Examples: 
conditionalWhile(0, defineLambdaFunction'$i<5',defineLambdaFunction '$i+1') == 5
conditionalWhile(5, defineLambdaFunction'$i<5',defineLambdaFunction '$i+1') == 5

Group: constant
Name: constantAtomicMass
Type: variable
This variable is locked: cannot be changed by user
Help: [kg] In physics and chemistry, the atomic mass constant, mu, is one twelfth of the mass of an unbound atom of the carbon-12 nuclei at rest and in its ground state.

Group: constant
Name: constantAvogadro
Type: variable
This variable is locked: cannot be changed by user
Help: [1/mol] The Avogadro constant (symbols: L, NA) is the number of "elementary entities" (usually atoms or molecules) in one mole, that is (from the definition of the mole), the number of atoms in exactly 12 grams of carbon-12.

Group: constant
Name: constantBoltzmann
Type: variable
This variable is locked: cannot be changed by user
Help: [J/K] The Boltzmann constant (k or kB) is the physical constant relating energy at the particle level with temperature observed at the bulk level. It is the gas constant R divided by the Avogadro constant NA.

Group: constant
Name: constantConductanceQuantum
Type: variable
This variable is locked: cannot be changed by user
Help: [S] The conductance quantum is the quantized unit of conductance. It is defined by rac{2e^2}{h} and equals 77.5 microsiemens, which corresponds to 12.9kΩ. The conductance quantum is often denoted as G0.

Group: constant
Name: constantCopperResistivity
Type: variable
This variable is locked: cannot be changed by user
Help: [ohm m] resistivity of copper at 25°C

Group: constant
Name: constantE
Type: variable
This variable is locked: cannot be changed by user
Help: The lim x->infinity (1+1/x)^x. Instead of e, constantE takes into account that e can be stored with a given accuracy in the system.

Group: constant
Name: constantElectricconstant
Type: variable
This variable is locked: cannot be changed by user
Help: [F/m] The parameter ε0 (commonly called the vacuum permittivity, permittivity of free space or electric constant[1][2]) is a constant used in connection with the rationalized meter-kilogram-second (rmks) equation system.

Group: constant
Name: constantElectronMass
Type: variable
This variable is locked: cannot be changed by user
Help: [kg] The mass of an electron.

Group: constant
Name: constantElectronVolt
Type: variable
This variable is locked: cannot be changed by user
Help: [J] In physics, the electron volt (symbol eV; also written electron-volt according to the NIST, IUPAC,[1] and BIPM[2]) is a unit of energy. By definition, it is equal to the amount of kinetic energy gained by a single unbound electron when it accelerates through an electrostatic potential difference of one volt.

Group: constant
Name: constantElementaryCharge
Type: variable
This variable is locked: cannot be changed by user
Help: [C] The elementary charge, usually denoted e,[1] is the electric charge carried by a single proton, or equivalently, the negative of the electric charge carried by a single electron.

Group: constant
Name: constantFaraday
Type: variable
This variable is locked: cannot be changed by user
Help: [C/mol] In physics and chemistry, the Faraday constant (named after Michael Faraday) is the magnitude of electric charge per mole of electrons.

Group: constant
Name: constantFineStructure
Type: variable
This variable is locked: cannot be changed by user
Help: [] In physics, the fine-structure constant (usually denoted α, the Greek letter alpha) is a fundamental physical constant, namely the coupling constant characterizing the strength of the electromagnetic interaction.

Group: constant
Name: constantMagnetic
Type: variable
This variable is locked: cannot be changed by user
Help: [N/A^2] The parameter μ0 (called vacuum permeability, permeability of free space or magnetic constant) is a constant used in connection with the rationalized meter-kilogram-second (rmks) system of electromagnetic equations.

Group: constant
Name: constantMagneticFluxQuantum
Type: variable
This variable is locked: cannot be changed by user
Help: [Wb] The magnetic flux quantum Φ0 is the quantum of magnetic flux passing through a superconductor.

Group: constant
Name: constantMolarGas
Type: variable
This variable is locked: cannot be changed by user
Help: [J/mol/K] It is equivalent to the Boltzmann constant, but expressed in units of energy (i.e. the pressure-volume product) per kelvin per mole (rather than energy per kelvin per particle).

Group: constant
Name: constantNewton
Type: variable
This variable is locked: cannot be changed by user
Help: [m^3/kg/s^2] According to the law of universal gravitation, the attractive force (F) between two bodies is proportional to the product of their masses (m1 and m2), and inversely proportional to the square of the distance (r) between them: F = G / (m_1 m_2 r^2). The constant of proportionality, G, is the gravitational constant.

Group: constant
Name: constantPI
Type: variable
This variable is locked: cannot be changed by user
Help: The ratio between a circunference and its diameter. Instead of pi, constantPI takes into account of the accuracy on which pi can be stored in the system.

Group: constant
Name: constantPlanck
Type: variable
This variable is locked: cannot be changed by user
Help: [J s] The Planck constant is the proportionality constant between energy (E) of a photon and the frequency of its associated electromagnetic wave (ν).

Group: constant
Name: constantProtonMass
Type: variable
This variable is locked: cannot be changed by user
Help: [kg] The mass of a proton.

Group: constant
Name: constantRydberg
Type: variable
This variable is locked: cannot be changed by user
Help: [1/m] The Rydberg constant represents the limiting value of the highest wave number (the inverse wavelength) of any photon that can be emitted from the hydrogen atom, or, alternatively, the wave number of the lowest-energy photon capable of ionizing the hydrogen atom from its ground state.

Group: constant
Name: constantSpeedOfLight
Type: variable
This variable is locked: cannot be changed by user
Help: [m/s] In physics, the speed of light (usually denoted c) refers to a fundamental physical constant, the speed at which light and all electromagnetic radiation travel in a perfect vacuum, which is 299,792,458 meters per second (about 300,000 kilometers per second or 186,000 miles per second).

Group: constant
Name: constantStefanBoltzmann
Type: variable
This variable is locked: cannot be changed by user
Help: [W/m^2/K^4] The Stefan–Boltzmann constant (also Stefan's constant), a physical constant denoted by the Greek letter σ, is the constant of proportionality in the Stefan–Boltzmann law: the total energy radiated per unit surface area of a black body in unit time is proportional to the fourth power of the thermodynamic temperature.

Group: convert
Name: convertDayToSecond
Type: variable
This variable is locked: cannot be changed by user
Help: This constant can be used to convert from a measure unit to another. Multiply this constant for day to get second. This constants is based on the following equivalence 1 day = 86400.0second.

Group: convert
Name: convertDegreeToRadiant
Type: variable
This variable is locked: cannot be changed by user
Help: This constant can be used to convert from a measure unit to another. Multiply this constant for degree to get radiant. This constants is based on the following equivalence 1 degree = 0.017453292519943295radiant.

Group: convert
Name: convertFootPerHourToMeterPerSecond
Type: variable
This variable is locked: cannot be changed by user
Help: This constant can be used to convert from a measure unit to another. Multiply this constant for footPerHour to get meterPerSecond. This constants is based on the following equivalence 1 footPerHour = 8.46666667E-5meterPerSecond.

Group: convert
Name: convertFootToMeter
Type: variable
This variable is locked: cannot be changed by user
Help: This constant can be used to convert from a measure unit to another. Multiply this constant for foot to get meter. This constants is based on the following equivalence 1 foot = 0.3048meter.

Group: convert
Name: convertHourToSecond
Type: variable
This variable is locked: cannot be changed by user
Help: This constant can be used to convert from a measure unit to another. Multiply this constant for hour to get second. This constants is based on the following equivalence 1 hour = 3600.0second.

Group: convert
Name: convertInchesToMeter
Type: variable
This variable is locked: cannot be changed by user
Help: This constant can be used to convert from a measure unit to another. Multiply this constant for inches to get meter. This constants is based on the following equivalence 1 inches = 0.0254meter.

Group: convert
Name: convertKMeterPerHourToMeterPerSecond
Type: variable
This variable is locked: cannot be changed by user
Help: This constant can be used to convert from a measure unit to another. Multiply this constant for kMeterPerHour to get meterPerSecond. This constants is based on the following equivalence 1 kMeterPerHour = 0.277777778meterPerSecond.

Group: convert
Name: convertKnotToMeterPerSecond
Type: variable
This variable is locked: cannot be changed by user
Help: This constant can be used to convert from a measure unit to another. Multiply this constant for knot to get meterPerSecond. This constants is based on the following equivalence 1 knot = 0.514444444meterPerSecond.

Group: convert
Name: convertMilePerHourToMeterPerSecond
Type: variable
This variable is locked: cannot be changed by user
Help: This constant can be used to convert from a measure unit to another. Multiply this constant for milePerHour to get meterPerSecond. This constants is based on the following equivalence 1 milePerHour = 0.44704meterPerSecond.

Group: convert
Name: convertMonthToSecond
Type: variable
This variable is locked: cannot be changed by user
Help: This constant can be used to convert from a measure unit to another. Multiply this constant for month to get second. This constants is based on the following equivalence 1 month = 2629743.83second.

Group: convert
Name: convertOunceToKilogram
Type: variable
This variable is locked: cannot be changed by user
Help: This constant can be used to convert from a measure unit to another. Multiply this constant for ounce to get kilogram. This constants is based on the following equivalence 1 ounce = 0.0283495231kilogram.

Group: convert
Name: convertPoundToKilogram
Type: variable
This variable is locked: cannot be changed by user
Help: This constant can be used to convert from a measure unit to another. Multiply this constant for pound to get kilogram. This constants is based on the following equivalence 1 pound = 0.45359237kilogram.

Group: convert
Name: convertYardToMeter
Type: variable
This variable is locked: cannot be changed by user
Help: This constant can be used to convert from a measure unit to another. Multiply this constant for yard to get meter. This constants is based on the following equivalence 1 yard = 0.9144meter.

Group: convert
Name: convertYearToSecond
Type: variable
This variable is locked: cannot be changed by user
Help: This constant can be used to convert from a measure unit to another. Multiply this constant for year to get second. This constants is based on the following equivalence 1 year = 3.1556926E7second.

Group: decibel
Name: decibelAmpToDb
Type: prefix function
Number of args: 1
Supported domain: (Positive Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: decibelAmpToDb converts a linear interval to a logarithmic value.
It returns: 20*log a.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
decibelAmpToDb(100) == 40

Group: decibel
Name: decibelDbAmpToLin
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: decibelDbAmpToLin converts decibel to linear value.
It converts a logarithmic interval a to a linear one returning: 10^(a/20).
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
decibelDbAmpToLin(40) == 100

Group: decibel
Name: decibelDbPowToLin
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: decibelDbPowToLin converts decibel to linear value.
It converts a logarithmic interval a to a linear one returning: 10^(a/10).
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
decibelDbPowToLin(20) == 100

Group: decibel
Name: decibelPowToDb
Type: prefix function
Number of args: 1
Supported domain: (Positive Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: decibelPowToDb converts a linear interval to a logarithmic value.
It returns: 10*log a.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
decibelPowToDb(100) == 20

Group: define
Name: #=
Type: infix function
Number of left args:  variable
Number of right args: 1
Supported left domain: (Literal,Interval)
Supported right domain: (Prefix Function with at least 1 arguments)
Priority: 1, Min Priority: 0, Max Priority: 13
Associativity: right to left
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: ($f, value0, $x, ..) #=  $g would define the function f (x) = g (value0, x).
It is useful to define a new function which executes the same of a given function but takes less parameter because some of them are fixed. The syntax is ($newFunctionName, interval if this param is fixed, any literal if this parameter is variable, ..) #= $functionName. The fixed parameters are kept in the same position as on #= definition. For instance defining ($f, $x, 10) #= $g, then f(1) will execute g(1, 10) while with ($f, 10, $x) #= $g then f 1 will execute g (10, 1). This function is useful because some ICE function works on function names with a given number of arguments. In those case #= can be used to fix the  parametric parameters. For example it can be used to plot several times a two argument function changing a parameter. It can also be used to define an alias for an already existint function to make it shorter.
Examples: 
(($f, x, y)='x+2*y';($g,$x,5)#=$f;g(1,2,3)) == (11,12,13)
(($g,5,$x)#=$f;g(1,2,3)) == (7,9,11)
(($f, x, y, z)='x+2*y+3*z';($g,$x,5,$x)#=$f;g(1,2)) == (17)
(($f, x, y) = 'y +sin x';($h, k) = 'calculusIntegrate(($g, $x, k) #= $f , 0_PI)';equationFindRoot($h, 0_2, 2+PI)) == (1)
(;($aliasSin, $x)#=$sin;aliasSin(1 .. 6) == sin (1 .. 6)) == (1,1,1,1,1,1)

Group: define
Name: :=
Type: infix function
Number of left args: 1
Number of right args:  at least 4
Supported left domain: (Literal)
Supported right domain: Matrix: (everything)
Priority: 1, Min Priority: 0, Max Priority: 13
Associativity: right to left
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: $function := [[xMatrixColumn],[yMatrixColumn]] defines the function as interpolation of the give matrix of points.
The function is an interpolation of a 2 columns graphics, like the one can be used to plot draws on the screen. Each row of the matrix is composed by the following couple of intervals xi f(xi). Every row needs to have xi+1 > xi, the only interception accepted is right(xi) == left(xi+1). The output f(x) will be equal to f(xi) while x is a subset of xi. If x is between xi and xi+1 the output depends on the interpolator selected on defineFunctionByPoints, interpolationType. 0 will use the average between f(xi) and f(xi+1), 1 a linear conjunction and 2 a cubic constrained spline. If xi and xi+1 has the same right and left extreme (right(xi)==left(xi+1)=ex) then f(ex) may return f(xi) or f(xi+1), the result is not predictable. The operation returns the function names in order to be immediately used in the current operation.
Examples: 
($intfunc:=[[1,2],[3,4],[5,6]];intfunc(-1.5), intfunc(1.5),intfunc(3),intfunc(10), intfunc(1_3), intfunc(1.5_3.5),intfunc(3_1), intfunc(3.5_1.5)) == (2,3,4,6,2_4, 3_5,4_2,5_3)
($intfunc:=[[1_5,2],[5_6,4],[6_10,6]];intfunc(-1.5), intfunc(3),intfunc(4.9),intfunc(10),intfunc(4_5.9), intfunc(5.9_4)) == (2,2,2,6,2_4,4_2)

Group: define
Name: =
Type: infix function
Number of left args:  variable
Number of right args:  at least 1
Supported left domain: (everything)
Supported right domain: (everything)
Priority: 1, Min Priority: 0, Max Priority: 13
Associativity: right to left
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: $a = 5 defines the variable a to 5. ($f, $x0, .., $xn)  = 'expression of x0 .. xn' defines the functin f(x0, .., xn) as expression (x0, .., xn).
It sets a variable or a function value 'a'=(1,2,3%2). For a variable write the variable name between commas then = and then the value. It is allowed a multiple assignement if a list of literals is set equal to a list of intervals: ('a','b','c') = (1,2,3). For functions write ( the function name between commas, the variable names between commas) = the function body: ('f','x','y')='x+y' sets the function f(x,y) = x+y. If the function name or parameter names appear for the first time it is possible to avoid the use of commas: a=5; (f,x)='2*x' gives error only if a, f or x were already defined. The set operation on variables returns the value and on functions the function names in order to be immediately used in the current operation. Please note when a function or variable is defined all other variables involved (with exception of parameters) must be known because their value is stored (i.e.: ('f','x')='2*a*x', if you later change the variable 'a' value, that will not affect f(x)). When a function is defined by default itself is given like parameter in order to create recursive functions, i.e.: (f,x) = '1,returnthisif(x<=1);x*f(x-1). It is possible to add multiple-line expressions. To do so just use the char sequence 
 to separate the lines or the multiple line literal syntax where each literal ends with '+ until the string is not completed. The instructions on a multiline use intermediate variable to share the computation, however the user should take care not using variable alrady defined otherwise the value will be fixed at the one of the definition time. To overwrite ICE functions see overwriteembeddedfunctions.
Examples: 
($a=(1,2,3);a+1) == ((2,3,4))
(($f,$x,$y)='x+y';f(5,6)) == (11)
(($g,$x)='x,2*x';g(2)) == ((2,4))
(($l,$x)='2*x';($n,$x)='l(x+1)';n(3)) == (8)
($a=0;5+($a=3),a) == (8,3)
(;equationFindRoot(($l,$x)='2*x+2',-2_0,0)) == (-1)
(defineDelete($n);($n,$x)='1,flowControlReturnThisIf (x <= 1);x*n(x-1)';n (5)) == (120)
(($a,$b)=(1,2);($a,$b)=(b,a);(a==2,b==1)) == (1,1)
(;justCreatedVariable = 0, justCreatedVariable +1) == (0,1)
(;($justCreatedFunction, $x)='2*x', justCreatedFunction 4) == ('justCreatedFunction', 8)
(($multiLineFunc, $a) = 'zza = a * 2 
 zzb = zza * 3 
 zzb * 4';multiLineFunc 3) == (3*2*3*4)
(($t1, $a)='2*a';($t2, $a)='3*t1 a, 3*t1 a';($t3, $a)='4*t2 a, 4*t2 a'; t3 1) == (24,24,24,24)

Group: define
Name: _=
Type: infix function
Number of left args:  variable
Number of right args:  at least 1
Supported left domain: (everything)
Supported right domain: (everything)
Priority: 1, Min Priority: 0, Max Priority: 13
Associativity: right to left
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: ($f, $x1, .., $xn) _= 'expression' to define the following compiled expression f(x1, .., xn) = expression(x1, .., xn).
It is used to create compiled functions which are at least 10% faster then interpreted functions defined with '='. Ex.: ($f,$x,$y)='x+y' sets the function f(x,y) = x+y, ('f','x'='x,2*x' set the function f which gets the parameter x and returns a list of two elements (x,2*x). The compiled functions do not support control flow neither ';'. The compiled function parameters type and size are not checked at run time, which may rise exceptions. Compiled function supports an optimization, which to work requires the variable to be at the end of the expression (i.e.: ('f','x')_='1+2+3+4+5+6+7+8+9*x' is 25% faster than its interpreted function, while ('f','x')_='9*x+1+2+3+4+5+6+7+8' is just 15% faster). Please note when a function is defined all other variables involved (with exception of parameters) must be known because their value is stored (i.e.: ('f','x')='2*a*x', if you later change the variable 'a' value, that will not affect f(x)). '_='  behaves exactly like '=' for variable definition.
Examples: 
(($n,$x,$y)_='2*x+5*y';n(5,6)) == (40)

Group: define
Name: defineALL
Parameter: currentGroup
Value: 
Expected Input: Requires literal value
Default: 
Help: sets the group name for the new functions and variables created.
All the functions (and variables) created will have that group. If it is called with '' as argument it returns the current group without any set, if it is called with 'CLEARGROUPNAME' argument it sets the current group to ''. By default the current group is ''. It is possible to work with several groups at the same time calling with 'MULTIGROUP'. Then when some new element is defined it will look for the first upper case character to understand where is the group and where the name. If the input is 'CLEARGROUPNAME' the search path is cleared.

Group: define
Name: defineContextBegin
Type: prefix function
Number of args: 0
Supported domain: (Literal)
Does not extend to list
This function is locked: cannot be changed by user
Help: defineContextBegin () will create a new context for variables or prefix function definition and returns the current context level.
The first context is at level 1. Every time a variable is made it is created in the current context level. Every time the system looks for a variable is search in the current level. If it is not found it looks in the level before and so on unti the first level is reached.
Examples: 
a=1, b=2, c=3;a,b,c,d == 1,2,3,'d'
defineContextBegin, b =4, d=5;a,b,c,d == 1,4,3,5
defineContextEnd;a,b,c,d == 1,2,3,'d'

Group: define
Name: defineContextEnd
Type: prefix function
Number of args: 0
Supported domain: (Literal)
Does not extend to list
This function is locked: cannot be changed by user
Help: defineContextEnd () will end the current context and go to the one before returning its value.
It will lose all the variables created here. The first context is at level 1 and it is not possible to end it. Every time a variable is made it is created in the current context level. Every time the system looks for a variable is search in the current level. If it is not found it looks in the level before and so on unti the first level is reached.
Examples: 
;sin PI == 0
defineContextBegin, ($sin, $x) = ' 2*x'; sin PI == 2*PI
defineContextEnd; sin PI == 0

Group: define
Name: defineDelete
Type: prefix function
Number of args: 1
Supported domain: (Literal)
Automatically extends to list
This function is locked: cannot be changed by user
Help: defineDelete $a would delete the symbol a.
The symbol to delete may be a variable, a function (infix or prefix), a measurement unit. Ex.: delete ('x') deletes the variable or function x. The ICE functions are locked, so they cannot be deleted. To add or remove the lock of a function defineFunctionLock Set and Clear.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
ada=5;defineDelete $ada;ada == 'ada'

Group: define
Name: defineDeleteAll
Type: prefix function
Number of args: 0
Supported domain:  everything
Does not extend to list
This function is locked: cannot be changed by user
Help: defineDeleteAll would delete all the functions and variables without a lock.
Used in the middle of a session would delete all the function defined by the users (which are not locked by default)..
Examples: 
a=5,b=2;defineDeleteAll;a,b == 'a','b'

Group: define
Name: defineFunctionByPoints
Parameter: interpolationType
Value: 0
Expected Input: Requires integer value between 0 and 2
Default: 0
Help: The type of interpolation algorithm to be used to fit region between intervals. By default if the x interval is matched the y stored is used. If the x input falls between 2 inputs: 0 is the default and uses the average (can fit points and intervals), 1 uses a linear regression, 2 use a cubic constrained spline (Constrained Cubic Spline Interpolation for Chemical Engineering Applications by CJC Kruger: http://www.korf.co.uk/spline.pdf and Spline interpolation From Wikipedia, the free encyclopedia http://en.wikipedia.org/wiki/Spline_interpolation#Algorithm_to_find_the_interpolating_cubic_spline

Group: define
Name: defineFunctionInfix
Type: prefix function
Number of args: 5
Supported domain: ({Interval List of []},Literal,{Interval List of []},Literal,Literal)
Does not extend to list
This function is locked: cannot be changed by user
Help: defineFunctionInfix ({$leftVar1, ..}, '+*/', {$rightVar1, ..}, 'expression with left and right vars', 'priority') defines the new infix function (leftVar1, ..) +*/ ($rightVar1, ..) = expression at given precedence,
The priority is a literal of the following list (priority aschending) 'list':  left associative; 'set':  right associative; 'set2':  right associative; 'or':  left associative; 'and':  left associative; 'union':  left associative; 'intersection':  left associative; 'equal':  left associative; 'compare':  left associative; 'sum':  left associative; 'times':  left associative; 'power':  right associative; 'get':  left associative; 'create':  left associative; 
Examples: 
defineFunctionInfix({$a}, '*/*', {$b}, 'a*b/(a+b)', 'sum'); diffuseCumulate('*/*',5, 10) == 5*10/15

Group: define
Name: defineFunctionInverse
Type: prefix function
Number of args: 4
Supported domain: (Prefix Function with 1 arguments,Literal,Point Interval,Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: $invFunc defineFunctionInverse [[xMatrixColumn], [yMatrixColumn]] would define an inversion function of the given matrix (y becomes x and x becomes y).
It can be used to create an interpolation of the inverse function given: from y = f (x) it will create x = inversef (y). Provide the function name to invert, the name of the inverse function, the number of points to use, the interval in which it has to be inverted..
Examples: 
defineFunctionInverse($sin,$inversesin, 21,0_PI/2); inversesin(sin(0, PI/20, PI*5/20, PI*10/20)) == 0, PI/20, PI*5/20, PI*10/20

Group: define
Name: defineFunctionShowAll
Type: prefix function
Number of args: 0
Supported domain:  everything
Does not extend to list
This function is locked: cannot be changed by user
Help: defineFunctionShowAll () returns the list of all functions (prefix and inifx) and variables defined.
Examples: 
;defineFunctionShowAll ? (literalRegularExpressionMatch('optimiz.*',defineFunctionShowAll )) == 'optimizationUnconditionalMinimum'

Group: define
Name: defineGroupGet
Type: prefix function
Number of args: 1
Supported domain: (Literal)
Automatically extends to list
This function is locked: cannot be changed by user
Help: defineGroupGet ($function) returns the group of the given function (infix or prefix) or variable.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
defineGroupGet('defineGroupGet','*','help') == 'define','arithmetic','information'

Group: define
Name: defineGroupSearchPath
Type: prefix function
Number of args: at least 1
Supported domain: (Literal)
Does not extend to list
This function is locked: cannot be changed by user
Help: defineGroupSearchPath ('group1', 'group2', 'group3', ..) will automatically search prefix and variable on all the given groups.
For instance if the seach group path is 'define' the call 'function (5)' will look for function and if not found for definefunction. If the input is '' the current search group is returned. If the input is 'CLEARGROUPNAME' the search pat is cleared.
Examples: 
defineGroupSearchPath('information');abt=About();defineGroupSearchPath('CLEARGROUPNAME');abt == informationAbout()

Group: define
Name: defineLambdaFunction
Type: prefix function
Number of args: at least 1
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: defineLambdaFunction ('expression of $a, $b, .., $z) creates an unnamed function as expression(a, b, .., z).
Lambda functions are temporary functions which are automatically deleted at the end of the current expression execution. They are useful when it is necessary to create a function for some purpose but it is not required to save the function itself in the enviroment. The typical example is to plot a function. defineLambdaFunction has a syntax designed to create quickly a function. If defineLambdaFunction input is a literal, it creates a new function extrapolatin all the variables as the identifier beginning with $ ordered in alphabetical order: defineLambdaFunction('$b+2*$a') is like (defineLambdaGetName, $a, $b)='b+2*a'. If defineLambdaFunction input is a {sub-list} cointaining a matrix it defines an interpolation lambda function, i.e.: defineLambdaFunction ({[[1,2],[3,4]]}) is equivalent to getLambdaName := [[1,2],[3,4]]. If defineLambdaFunction input is a { sub-list }, it defines a sub argument input function, i.e. defineLambdaFunction ({2,$x,$f}) is equivalent to (getLambdaName, 2, $x) #= $f. For more complex definitions it is required to use getLambdaName and the proper function. As default defineLambdaFunction returns the temporary function name to be used by other functions. However if a list of intervals follows, the functions just create is applied to the list and the result is returned.
Examples: 
;plotStandard(defineLambdaFunction('2*$x+2'), 10, 1_10) == listShuffle({1 .. 10}, {4 .. 22 .. 2}) # 2
;defineLambdaFunction('2*$x+2', 1 .. 4) == 4 .. 10 .. 2
;plotStandard(defineLambdaFunction({listShuffle({1 .. 10}, {4 .. 22 .. 2}) # 2}), 10, 1_10) == listShuffle({1 .. 10}, {4 .. 22 .. 2}) # 2
;defineLambdaFunction({listShuffle({1 .. 10}, {4 .. 22 .. 2}) # 2},1,10) == 4,22
($g, $x, $y)= 'x + 2* y + 5';plotStandard(defineLambdaFunction({2, $x, $g}), 4, 1_4) == listShuffle({1 .. 4}, {9 .. 15 .. 2}) # 2

Group: define
Name: defineLambdaGetName
Type: prefix function
Number of args: 1
Supported domain: (Point Interval and Integer Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: defineLambdaGetName (x) provides a new temporary name (to be used for declare function or variable) or it returns the ones already generated.
It builds the names for the next Lambda function name if x >=0. If x < 0 it provides the previous lamba function name generated on this command session. Lambda functins are temporary functions which are automatically deleted at the end of the current expression execution. They are useful when it is necessary to create a function for some purpose but it is not required to save the function itself. The typical example is to plot a function.
Examples: 
;programCallFunction((defineLambdaGetName 0, $x)='2*x+2',3,5) == 8, 12
;plotStandard((defineLambdaGetName 0, $x)='3*x-1',4, 1_4)  == listShuffle({1 .. 4}, {2,5,8,11})
; defineLambdaGetName 0 = listLinear (10, 1_10); literalToExpression(defineLambdaGetName (-1)) # 1, sin (literalToExpression(defineLambdaGetName (-1))) # 1 == plotStandard($sin, 10, 1_10)

Group: define
Name: defineLambdaGetValue
Type: prefix function
Number of args: 1
Supported domain: (Point Interval and Integer Interval and Not Positive Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: defineLambdaGetValue (-x) returns the value stored in the -x LambdaName.
It is the same of literalToExpression defineLambdaGetName -x.
Examples: 
;as=statisticRandomListAsDistribution($statisticDistributionUniform, 1_2, $x, 0_3);defineLambdaGetName (0) = as-as;  statisticAverage defineLambdaGetValue -1, statisticMeanAbsoluteDeviation  defineLambdaGetValue -1 == 0, 0

Group: define
Name: defineLockClear
Type: prefix function
Number of args: 1
Supported domain: (Literal)
Automatically extends to list
This function is locked: cannot be changed by user
Help: defineLockClear ($functionName) clear the lock in the given function name (It can be prefix, infix or variable function).
When a lock is cleared it is not possible to overwrite or delete the given function. By default all the ICE system function are locked. It is possible to remove  a lock by defineFunctionLockClear. Since ICE is compiletd wwith early binding, although a function is deleted or renamed, it is still available (its pointer actually) in all the previous function used to refer to it. Calling the function on ALLFUNCTIONSDEFINED all the registered functions (prefix, infix) and variable lock is cleared.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
defineLockClear ($tan);($oldtan, $x) #= $tan; ($tan,x)='2+x';$result = (tan (0, PI/4), oldtan (0, PI/4));($tan, $x) #= $oldtan; defineLockSet($tan); result == 2, 2+PI/4, 0, 1

Group: define
Name: defineLockSet
Type: prefix function
Number of args: 1
Supported domain: (Literal)
Automatically extends to list
This function is locked: cannot be changed by user
Help: defineLockSet ($functionName) set the lock in the given symbo.
The symbol may be a prefix, infix, variable function or a measurement unit.
When a lock is set it is not possible to overwrite or delete the given function. By the defaultIf all the system functions are locked. It is possible to remove  a lock by defineFunctionLockClear. Since ICE is compiletd, although a function is deleted or renamed, it is still available in all the previous function used to refer to it. For examples look at LockClear. Calling the function on ALLFUNCTIONSDEFINED all the registered functions (prefix, infix and measurement unit) and variable lock is set.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.

Group: define
Name: defineSummaryUserDefinition
Type: prefix function
Number of args: 0
Supported domain:  everything
Does not extend to list
This function is locked: cannot be changed by user
Help: defineSummaryUserDefinition () returns the summary of all functions (prefix and inifx) and variables defined by the user.
To choice if the function is defined by the user it check it is not locked and it doen not begin by 'answer'.

Group: diffuse
Name: diffuseAccumulateOnLeft
Type: prefix function
Number of args: at least 3
Supported domain: (Function Variable,Infix Function with at least 1 left arguments and with at least 1 right arguments,Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: diffuseAccumulateOnLeft ($accumulator, 'infixFunction', b1, .., bn) computes: accumulator = accumulator 'infixFunction' (b1, .., bn).
 It can be used to simplify expression like a = a + 4.
Examples: 
; $a=0 == 0
diffuseAccumulateOnLeft($a, '-', 5) == -5
diffuseAccumulateOnLeft($a, ',', 6,7,8) == -5,6,7,8

Group: diffuse
Name: diffuseAccumulateOnRight
Type: prefix function
Number of args: at least 3
Supported domain: (Function Variable,Infix Function with at least 1 left arguments and with at least 1 right arguments,Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: diffuseAccumulateOnRight ($accumulator, 'infixFunction', b1, .., bn) computes: accumulator = (b1, .., bn) 'infixFunction' accomulator.
 It can be used to simplify expression like a = 4 + a.
Examples: 
; $a=0 == 0
diffuseAccumulateOnRight($a, '-', 5) == 5
diffuseAccumulateOnRight($a, ',', 6,7,8) == 6,7,8,5

Group: diffuse
Name: diffuseCumulate
Type: prefix function
Number of args: at least 2
Supported domain: (Infix Function with 1 left arguments and with 1 right arguments,Complex Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: diffuseCumulate ('infixFunction', x1, .., xn) applies the given infixfunction at the first and second element of the list, the result is computed with the third element of the list and so on.
For example diffuseCumulate ('+', 1, 2, 3) = ((1+2)+3). If the infix function returns more than an element only the first is used.
Examples: 
diffuseCumulate('+', 1, 2, 3) == 6
diffuseCumulate('-', 1, 2, 3) == -4
diffuseCumulate('&&', 1, 0_1, 0_1) == 0_1
diffuseCumulate('&&', 1, 0, 0_1) == 0
diffuseCumulate('*', 3, 2, 3) == 18
diffuseCumulate('||', 0, 0, 0) == 0
diffuseCumulate('||', 1, 0, 0_1) == 1
diffuseCumulate('+/', 1, 2, 3) == 0.545
diffuseCumulate('+^', 1, 2, 3) == 3.742

Group: diffuse
Name: diffuseExpandFunction
Type: prefix function
Number of args: at least 2
Supported domain: (Prefix Function with at least 1 arguments,Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: diffuseExpandFunction ($f, {a21, .., a2n}, .., {an1, .., ann}) returns (f(a21, .., a2n), .., (an1, .., ann)).
Usually ICE performs that expansion autonumosly: sin (1,2,3) == sin 1, sin 2, sin 3. However that is not the case for the function which may accept an unlimited set of arguments like for listSize.
Examples: 
a=(1,2,3), b=(4,5), c=(5); diffuseExpandFunction ($listSize,  {a}, {b}, {c}) == 3,2,1
;listSize ({a}, {b}, {c}) == 3
;listSize (a,b,c) == 6

Group: diffuse
Name: diffuseExpandParameters
Type: prefix function
Number of args: at least 2
Supported domain: (Prefix Function with at least 1 arguments,Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: diffuseExpandParameters ($f, a1, {a21, .., a2n}, .., {an1, .., ann}) returns the list given by applying f to each of its input expanding sub-list: f (a1, a21, .., an1), f(a1, a22, .., an2), .., f(a1, a2n, .., ann))
This function is useful to apply a prefix function (of several arguments) where some arguments can change in a list. Note that is performed automatically by ICE in most cases (1 argument function and on last arguments). If some argument of the function needs to be a sub-list it should be boxed within a sublist (adding a couple of extra curly brackets), diffuseExpandParameters will understand it is not a parameter to expand and will unbox for the calculus.
Examples: 
diffuseExpandParameters($sin, {1,2,3}) == sin(1,2,3)
diffuseExpandParameters( $equationFindRoot, $sin, {-1_1,1_4,4_7}, 0) == 0,PI,2*PI
diffuseExpandParameters($listClone, {2,3}, {3,4}) == listClone (2, 3), listClone(3,4)
diffuseExpandParameters($listClone, {2,3}, {{3,4}}) == listClone (2, {3,4}), listClone(3,{3,4})

Group: diffuse
Name: diffuseFeed
Type: prefix function
Number of args: at least 2
Supported domain: ({Interval List of []},Prefix Function with at least 1 arguments)
Does not extend to list
This function is locked: cannot be changed by user
Help: diffuseFeed ({longExpression}, $f1, $f2, .., $fn) returns the list given by f1(longExpression), f2(longExpression), .., fn(longExpression).
This function is provided only for efficiency because if is it complex compute long expression (and it is not useful to store it in a variable) it can be feeded to other function without compute it again.
Examples: 
diffuseFeed({0},$sin, $cos) == 0, 1
;diffuseFeed({statisticRandomListAsDistribution($statisticDistributionUniform, 1_2, $x, 0_3)},$statisticAverage ,$statisticMeanAbsoluteDeviation) << (1.4_1.6, .24_.26) == true, true

Group: diffuse
Name: diffuseSpread
Type: prefix function
Number of args: at least 3
Supported domain: (Infix Function with 1 left arguments and with 1 right arguments,Complex Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: diffuseSpread ('infixFunction', x1, .., xn) applies the given infix function sequentially to all the couples of the given list.
For example diffuseSpread ('+', 1, 2, 3) = ((1+2), (2+3)).
Examples: 
diffuseSpread('+', 1, 2, 3) == 3, 5
diffuseSpread('-', 1, 2, 3) == -1, -1
diffuseSpread('&&', 1, 0_1, 0_1) == 0_1, 0_1
diffuseSpread('&&', 1, 0, 0_1) == 0, 0
diffuseSpread('*', 3, 2, 3) == 6, 6
diffuseSpread('||', 0, 0, 0) == 0, 0
diffuseSpread('||', 1, 0, 0_1) == 1, 0_1
diffuseSpread('+/', 1, 2, 3) == 2/3, 6/5
diffuseSpread('+^', 1, 2, 3) == sqrt(5), sqrt(13)
diffuseSpread('_',listLinear(5,0_4)) == 0_1,1_2,2_3,3_4

Group: engineer
Name: +/
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Complex Interval)
Supported right domain: (Complex Interval)
Priority: 10, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a +/ b adds the inverse of the given vector of intervals and then inverts again the result: 1/(1/a+1/b). If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(2_4)+/(4_6) == (1.333333333_2.4)

Group: engineer
Name: +^
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Complex Interval)
Supported right domain: (Complex Interval)
Priority: 10, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a +^ b adds the square of the given list of intervals and then it squares root the result. It returns sqrt(sqr(a)+sqr(b)). If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(3_4)+^(4_5) == (5_6.403124237)

Group: engineer
Name: engineerFromColorCode
Type: prefix function
Number of args: at least 4
Supported domain: (Literal)
Automatically extends to list
This function is locked: cannot be changed by user
Help: engineerFromColorCode ('color1', 'color2', ..) returns the color code corresponding value.
The function converts the given color code to a numeric value.
Examples: 
engineerFromColorCode(brown, black, yellow, silver) == 100k%10
engineerFromColorCode(orange, orange, black, gold) == 33%5

Group: engineer
Name: engineerPartition
Type: prefix function
Number of args: 2
Supported domain: (Complex Interval,Complex Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: engineerPartition (Rd, Ru) computes the voltage across Rd (down) in the partitor Ru (up) and Rd.
It computes the partition ratio among the first given value and the sum of the two values: partition (a, b) = 1/(1+b/a).
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
engineerPartition(1, 2+ 3+ 4) == 0.1

Group: engineer
Name: engineerPartitionInverse
Type: prefix function
Number of args: 2
Supported domain: (Complex Interval,Complex Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: engineerPartitionInverse (Rd, Ru) known the voltage on Rd (down) compute the voltage across the the partitor Ru (up) and Rd.
It computes the partition ratio inverse among the given values: partitionInverse (a, b) = (1+b/a).
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
;5*engineerPartitionInverse(3,4)*engineerPartition(3,4) == 5

Group: engineer
Name: engineerPreferredValue
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: engineerPreferredValue (value%tolerance) returns the closer value and tolerage per the standarization industrial available vaules.
It finds the closest preferred value from standard IEC 60063.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
engineerPreferredValue(39%25) == 33%20

Group: engineer
Name: engineerPreferredValueCloser
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: engineerPreferredValueCloser (value%tolerance) returns the closer couple of values between the provided one (and tolerance).
It returns the list of the two closer preferred values from standard IEC 60063.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
engineerPreferredValueCloser(40%25) == 33%20, 47%20

Group: engineer
Name: engineerPreferredValueList
Type: prefix function
Number of args: 2
Supported domain: (Real Interval,Point Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: engineerPreferredValueList (beginInterval_endInterva, tolerance) returns the preferred valued from begin to end intervals with the given tolerance.
The input tolerances should be the same. The list of intervals begin with the preferred value before begin and ends with the preferred value after the end. If the order begin, end is the opposit the list will be provided in the reverse order.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
engineerPreferredValueList(10k_50k,20) == (10k,15k,22k,33k,47k,68k)%20

Group: engineer
Name: engineerPreferredValueScannerCloser
Type: prefix function
Number of args: at least 3
Supported domain: (Prefix Function with at least 1 arguments,Real Interval or {Interval List of []},Real Interval or {Interval List of []})
Automatically extends to list
This function is locked: cannot be changed by user
Help: engineerPreferredValueScannerCloser ($prefixFunc, {start1_stop1, tol1}, .., {startn_stopn, toln}, target) returns the {list of preferred values} closer but less to the target and the {list of values} equals to the targed and the list closer and higher of the target.
 If any parameter is given as itnerval it is taken the closer couple of preferred values where it fits. The target may be an intervalList if the function return list.
Examples: 
($sum,$a,$b)='a+b'; engineerPreferredValueScannerCloser($sum, {10k_100k, 20}, {10k_100k, 20}, 740k) == {100k, 100k},{},{}
engineerPreferredValueScannerCloser($sum, {1M_10M, 20}, {1M_10M, 20}, 740k) == {},{},{1M, 1M}
engineerPreferredValueScannerCloser($sum, {100k_1M, 20}, {100k_1M, 20}, 740k) == ({ 470k,  220k, 220k, 470k},{},{680k,  100k, 100k, 680k} )

Group: engineer
Name: engineerPreferredValueScannerLowest
Type: prefix function
Number of args: at least 3
Supported domain: (Prefix Function with at least 1 arguments,Real Interval or {Interval List of []},Real Interval or {Interval List of []})
Automatically extends to list
This function is locked: cannot be changed by user
Help: engineerPreferredValueScannerLowest ($prefixFunc, {start1_stop1, tol1}, .., {startn_stopn, toln}) returns the {list of preferred values} gives the lowest value of the function $prefixFunction.
 It can be used to optimize a set of values. If any parameter is given as itnerval it is taken the closer couple of preferred values where it fits. The target may be an intervalList if the function return list.
Examples: 
($seriesToOptimize, $a, $b) = 'abs(a+b-19k)'; engineerPreferredValueScannerLowest($seriesToOptimize, {1k_100k, 10}, {1k_100k, 10}) == {18k, 1k, 1k, 18k}

Group: engineer
Name: engineerSinglePoleTauS
Type: prefix function
Number of args: 2
Supported domain: (Real Interval,Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: engineerSinglePoleTauS (vbegin_vend, v1_v2) compute the taus required by the single pole system running from vbegin to vend to go from v1 to v2.
If the result is negative it means the system before goes through v2 and then to v1.It is possible to apply this function to multiple arguments just adding several intervals as last parameter. 
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
engineerSinglePoleTauS(0_1, 0.1_0.9) == 2.197
engineerSinglePoleTauS(0_1, 0.9_0.1) == -2.197

Group: engineer
Name: engineerToColorCode
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: engineerToColorCode converts the given value to a color code, use preferred function to be sure the color code does exists commercially. For example: engineerToColorCode(100K%10)=('brown','black','yellow','silver').
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
engineerToColorCode(100k%10) == brown, black, yellow, silver
engineerToColorCode(33%5) == orange, orange, black, gold

Group: equation
Name: equationActractiveFixedPoint
Parameter: epsilon
Value: 1.0E-5
Expected Input: Requires double value between 0.0 and 1.0
Default: 1.0E-5
Help: The maximum distance between two iterations, below this value it stops

Group: equation
Name: equationActractiveFixedPoint
Parameter: maxIteration
Value: 100
Expected Input: Requires integer value between 1 and 1000
Default: 100
Help: The maximum number of iterations, above which it stops

Group: equation
Name: equationActractiveFixedPoint
Type: prefix function
Number of args: at least 2
Supported domain: (Prefix Function with at least 1 arguments,Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: equationActractiveFixedPoint ($f1, .., $fn, x1, .., xn) solves a set of equations with iterative steps.
The equations should be in the form x1 = f1 (x1, .., xn), x2 = f2 (x1, .., xn), .. , xn = fn (x1, .., xn). It iterates from an initial point x1', .., xn' applying f1, .., fn to get a more accurate estimation x1'', .., xn'', until the difference between the current and previous solution is less than n * internal epson. If x1', .., xn' is an attractive fixed point of the function f the sequence will converge to the solution x. It needs the equation names and the starting point: equationActractiveFixedPoint ($f1, .., $fn, x1', .., xn').
Examples: 
'(x^2)-3*x+2 has solution 1 and 2';($sq1, $x)='sqrt(3*x-2)';($sq2, $x)='(x^2+2)/3';equationActractiveFixedPoint($sq1, 10), equationActractiveFixedPoint($sq2, -1) == 2, 1

Group: equation
Name: equationDiscreteValueScannerCloser
Type: prefix function
Number of args: at least 3
Supported domain: (Prefix Function with at least 1 arguments,Real Interval or {Interval List of []},Real Interval or {Interval List of []})
Automatically extends to list
This function is locked: cannot be changed by user
Help: equationDiscreteValueScannerCloser ($prefixFunc, val1, {val21, .., val2n}, .., valn-1, {valn1, .., valnm}, target) returns the {list of values} to get the function values closer less to the target, the {list of values} equals and the {list of values} closer and higher of the target.
dIf any parameter is given as itnerval it is used as is. The target may be an intervalList if the function returns a list. equationDiscreteValueScannerCloser scans all the possible value therefore it can be very slow.
Examples: 
;equationDiscreteValueScannerCloser(defineLambdaFunction('$a+$b'),{1 .. 6},{1 .. 6},11.5) == ( {6,  5, 5, 6}, {}, { 6,  6 })

Group: equation
Name: equationDiscreteValueScannerLowest
Type: prefix function
Number of args: at least 3
Supported domain: (Prefix Function with at least 1 arguments,Real Interval or {Interval List of []},Real Interval or {Interval List of []})
Automatically extends to list
This function is locked: cannot be changed by user
Help: equationDiscreteValueScannerLowest ($prefixFunc, val1, {val21, .., val2n}, .., valn-1, {valn1, .., valnm}) returns the {list of values} to get the lowest values of the function.
dIf any parameter is given as itnerval it is used as is. The target may be an intervalList if the function returns a list. equationDiscreteValueScannerLowest scans all the possible value therefore it can be very slow. To find the highest just run with -f.
Examples: 
;equationDiscreteValueScannerLowest(defineLambdaFunction('(3-$x)^2+(4-$y)^2'),{0 .. 10},{0 .. 10}) == ( {3,  4})
;equationDiscreteValueScannerLowest(defineLambdaFunction('((3-$x)*(5-$x))^2+(4-$y)^2'),{0 .. 10},{0 .. 10}) == {3,4,5,4}

Group: equation
Name: equationDiscreteValueScannerMatch
Type: prefix function
Number of args: at least 3
Supported domain: (Prefix Function with at least 1 arguments,Real Interval or {Interval List of []},Real Interval or {Interval List of []})
Automatically extends to list
This function is locked: cannot be changed by user
Help: equationDiscreteValueScannerMatch ($prefixBooleanFunc, val1, {val21, .., val2n}, .., valn-1, {valn1, .., valnm}) returns the {list of values} to get the values where all the element of the list returned by the function are true.
true is 1 and can be computed with logical operator. If any parameter is given as itnerval it is used as is. The target may be an intervalList if the function returns a list. equationDiscreteValueScannerMatch scans all the possible value therefore it can be very slow.
Examples: 
;equationDiscreteValueScannerMatch(defineLambdaFunction('$x+$y == 5 , $x > $y'), {0 .. 10}, {0 .. 10}) == {5,  0,  4,  1,  3,  2} 
;equationDiscreteValueScannerMatch(defineLambdaFunction('$x+$y == 5 , $x < $y'), {0 .. 10}, {0 .. 10}) == {2,  3,  1,  4,  0,  5}
;equationDiscreteValueScannerMatch(defineLambdaFunction('sqrt($x^2+$y^2) << 4.99_5.01 , $x > $y '), {listLinear(20, 0_10)}, {listLinear(20, 0_10)}) == {4.737,  1.579} 

Group: equation
Name: equationFind
Parameter: epsilon
Value: 1.0E-8
Expected Input: Requires double value between 0.0 and 1.0
Default: 1.0E-8
Help: The maximum distance between two iterations, below this value it stops

Group: equation
Name: equationFind
Parameter: maxIteration
Value: 300
Expected Input: Requires integer value between 1 and 1000
Default: 300
Help: The maximum number of iterations, above which it stops

Group: equation
Name: equationFindIntersection
Type: prefix function
Number of args: 3
Supported domain: (Prefix Function with 1 arguments,Prefix Function with 1 arguments,Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: equationFindIntersection ($f1, $f2, interval1, ..) finds the intersection between a couple of 'thick' functions f1 and f2 in the given intervals: interval1, interval2, .. .
It needs the function names and then the initial intervals containing the intersection. That interval will be shrunken to the smallest containing the intersection. It is used bisection method. If the function returns multiple variables only the first element will be used to find the intersection.It is possible to apply this function to multiple arguments just adding several intervals as last parameter. 
Examples: 
equationFindIntersection($sin, $cos, 0_PI, 1_2*PI) == -2*arcTan(1-sqrt(2)),2*(PI-arcTan(1+sqrt(2)))

Group: equation
Name: equationFindRoot
Type: prefix function
Number of args: 3
Supported domain: (Prefix Function with 1 arguments,Real Interval,Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: equationFindRoot ($f, interval, point1, point2, ..) finds the root of a 'thick' function f in the given interval beginning from point1, then point2, .. .
It needs the equation name, the initial interval containing the root (X) and the expected value (Y). It will be shrunken to the smallest interval containing the root. It is used bisection method. If the function returns multiple variables only the first element will be used to find the root.It is possible to apply this function to multiple arguments just adding several intervals as last parameter. 
Examples: 
equationFindRoot($sin, 1_4, 0, 0.5) == PI, 5*PI/6 

Group: equation
Name: equationFindRootNewton
Parameter: epsilon
Value: 0.1
Expected Input: Requires double value between 0.0 and 1.0
Default: 0.1
Help: The maximum distance between two iterations, below this value it stops

Group: equation
Name: equationFindRootNewton
Parameter: maxIteration
Value: 50
Expected Input: Requires integer value between 1 and 1000
Default: 50
Help: The maximum number of iterations, above which it stops

Group: equation
Name: equationFindRootNewton
Parameter: tolerance
Value: 1.0
Expected Input: Requires double value between 0.0 and 10.0
Default: 1.0
Help: The relative tolerance to be used around the points to compute the Jacobian

Group: equation
Name: equationFindRootNewton
Type: prefix function
Number of args: at least 1
Supported domain: ({Interval List of [Prefix Function with at least 1 arguments]},{Interval List of [Point Interval]})
Does not extend to list
This function is locked: cannot be changed by user
Help: equationFindRootNewton ({f1, .., fn},{x1, .., xn}) applies Newton methods to solve the equations with given starting point.
Examples: 
equationFindRootNewton({defineLambdaFunction('100/$x+50/$y-20'),defineLambdaFunction('$x+$y-15')},{12,6}) == 10,5

Group: equation
Name: equationGaussElimination
Type: prefix function
Number of args: at least 1
Supported domain: Matrix with 1 columns more than rows: (Complex Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: equationGaussElimination ([A matrix],[B matrix]) solves the simultaneous equation defined by A x = B.
It uses Gauss elimination algorithm. The source code was adapted from http://snippets.dzone.com/posts/show/4874. It is still not properly working on intervals, I have to understand if it is possible to solve simultaneous equations with real number, complex number and also intervals. Unfortunately using interval as input, due to interval missing of distributive property, the result is only approximate. Try with gaussseidel function instead for intervals.
Examples: 
equationGaussElimination((1, 2, 3, 4)#2,(5,6)#1) == (-4,4.5)#1
a=statisticRandom(listClone(9, -100_100))#3, b=statisticRandom(listClone(3, -100_100))#1;a ** equationGaussElimination(a,b)  == b
a=statisticRandom(listClone(9, -100_100))#3+I*statisticRandom(listClone(9, -100_100))#3, b=statisticRandom(listClone(3, -100_100))#1+I*statisticRandom(listClone(3, -100_100))#1;a ** equationGaussElimination(a,b)  == b

Group: equation
Name: equationGaussSeidel
Parameter: epsilon
Value: 0.1
Expected Input: Requires double value between 0.0 and 1.0
Default: 0.1
Help: The maximum distance between two iterations, below this value it stops

Group: equation
Name: equationGaussSeidel
Parameter: maxIteration
Value: 50
Expected Input: Requires integer value between 1 and 1000
Default: 50
Help: The maximum number of iterations, above which it stops

Group: equation
Name: equationGaussSeidel
Type: prefix function
Number of args: at least 1
Supported domain: Matrix with 2 columns more than rows: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: equationGaussSeidel ([A matrix], [B matrix], [x0 matrix]) solves the system of simultaneous equations A x = B beginning at X0 point.
It uses  Gauss Seidel algorithm. The matrix must be diagonal dominant to ensure the algorithm convergence.
Examples: 
equationGaussSeidel((10, 2, 3, 40)#2,(5,6)#1,(1,1)#1) == (0.47716, 0.11421)#1

Group: equation
Name: equationOrdinaryDifferentialEquationFirst
Type: prefix function
Number of args: at least 4
Supported domain: (Prefix Function with at least 2 arguments,Positive Interval and Point Interval,Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: equationOrdinaryDifferentialEquationFirst ($f, points, time interval, f0(0), .. fn(0)) solves a differential equation dy/dt = f(t, y), in the given time interval, beginning with initial condition f(0).
It uses explicit fourth order Runge-Kutta method. It needs the equation name f(t, y), the number of steps n, the time interval tb_te, the function value y(tb). equationOrdinaryDifferentialEquationFirst solves system of equation differential as well, provided as follows: equationOrdinaryDifferentialEquationFirst(name of y1' = f1(t,y1,..,yn),..,name of yn' = fn(t,y1,..,yn), points, tmin_tmax, y1(tmin), .., yn(tmin) 
Examples: 
;equationOrdinaryDifferentialEquationFirst(($ydot,t,$y)='y', 100, 0_4, 1)::(100,1) == E^4
;equationOrdinaryDifferentialEquationFirst(($ydot,t,$y)='y+t', 3000, 0_0.4, 1)::(3000,1) == 2*E^0.4-0.4-1

Group: file
Name: fileLoadCsvPointMatrix
Type: prefix function
Number of args: 1
Supported domain: (Literal)
Does not extend to list
This function is locked: cannot be changed by user
Help: fileLoadCsvPointMatrix ('filename') returns the matrix of real values contained in the ASCII file called 'filename'.
The values in the file has to be separated by ;. The first row is used to read the number of columns. If the next rows have more columns they are scraped, if less they are set to 0. Every row becomes a row of the returned matrix.
Examples: 
slex = (statisticRandom(listClone(10, 1_6))#2);diffuseCumulate ('+', slex - fileLoadCsvPointMatrix(fileSaveCsvPointMatrix('savelisttest', {slex}))) == 0

Group: file
Name: fileLoadList
Type: prefix function
Number of args: 1
Supported domain: (Literal)
Does not extend to list
This function is locked: cannot be changed by user
Help: fileLoadList ('filename') loads (and execute) an ICE expression (usually a list) from an ASCII text file whose name is 'filename' and returns its value.
Since it expects an ICE expression as input it can be very slow to execute. It can be used to get the data saved with savelist or to get data from other program structured as list. It may load every kind of expression like the file .ice saved from the console. To load data with high speed brute force algorith use: fileLoadPointMatrix or fileLoadCsvPointMatrix if it is saved in CSV format.
Examples: 
slex = (statisticRandom(listClone(10, 1_6)));diffuseCumulate ('+', slex - fileLoadList(fileSaveList('savelisttest',{slex}))) == 0

Group: file
Name: fileLoadPointMatrix
Parameter: decimalSeparator
Value: .
Expected Input: Requires literal value of length 1
Default: .
Help: It is used to separate number from decimal part.

Group: file
Name: fileLoadPointMatrix
Parameter: readLines
Value: 1
Expected Input: Requires integer value between 1 and 1000000
Default: 1
Help: Sets the number of lines to read before skipping lines.

Group: file
Name: fileLoadPointMatrix
Parameter: skipLines
Value: 0
Expected Input: Requires integer value between 0 and 1000000
Default: 0
Help: Sets the number of lines to skip after the read lines. Use 0 to get all the matrix.

Group: file
Name: fileLoadPointMatrix
Parameter: stringDelimitator
Value: "
Expected Input: Requires literal value of length 1
Default: "
Help: It is used to delimit literal.

Group: file
Name: fileLoadPointMatrix
Parameter: valueSeparator
Value: ;
Expected Input: Requires literal value of length 1
Default: ;
Help: It is used tu separate values on one line.

Group: file
Name: fileLoadPointMatrix
Type: prefix function
Number of args: 1
Supported domain: (Literal)
Does not extend to list
This function is locked: cannot be changed by user
Help: fileLoadPointMatrix ('filename') loads a matrix of real values from the ASCII 'filename', reading readLines and skipping skipLines, using the given dotSeparator, commaSeparator, and string delimitator.
It is a kind of brute force high efficency reader: it tries to read as more as possible. It can be used to read data created with other programs like log files. Every row is expected to end with a new line. A number is [+-.][0..9]+ and it is translated in a point interval. If it is not possible to translate it is converted to literal. Every input row becomes a matrix row. It is possible to se several parameters by systemSetupSetParameter: the number of rows to read and then the ones to skip, the character used as decimal separator, the character used as value separator and the string delimitator.
Examples: 
slex = (statisticRandom(listClone(10, 1_6)));diffuseCumulate ('+', slex - fileLoadPointMatrix(fileSaveCsvPointMatrix('savelisttest',{slex}))) == 0

Group: file
Name: fileSaveCsvPointMatrix
Type: prefix function
Number of args: 2
Supported domain: (Literal,{Interval List of []})
Does not extend to list
This function is locked: cannot be changed by user
Help: fileSaveCsvPointMatrix ('fileName', {matrix}) saves the given matrix in fileName as CSV.
';' is used as separator. Requires the file name, the {sub-list} to be saved. If the file already exists it is overwritten. The value of each interval is saved, if the interval is a literal it is saved between "

Group: file
Name: fileSaveList
Type: prefix function
Number of args: 2
Supported domain: (Literal,{Interval List of []})
Does not extend to list
This function is locked: cannot be changed by user
Help: fileSaveList ('fileName', {value}) saves the value (list or matrix) in ICE syntax to fileName.
It can be loaded in a new execution of ICE. If the file already exists it is overwritten. It requires a literal with the file name and then the { sub-list } to be saved. The data is save in ASCII text mode.
Examples: 
slex = (statisticRandom(listClone(10, 1_6)));diffuseCumulate ('+', slex - fileLoadList(fileSaveList('savelisttest',{slex}))) == 0

Group: flowControl
Name: flowControlRepeatNextWhile
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: flowControlRepeatNextWhile (condition); nextSubExp; while the condition is true, executes the next sub-expression.
Every time the   current sub-expression is executed again to check if the condition is still true. The condition checked is that the inputs is true (== 1). This function is not supported by compiled function. The return value of this function is automatically removed from the result list.
Examples: 
i=0,j=5;i=i+1,flowControlRepeatNextWhile (i<10);j=j+1;j == 14

Group: flowControl
Name: flowControlRepeatPreviousWhile
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: prevSubExpression; flowControlRepeatPreviousWhile (condition); repeats the previous sub-expression while the condition is true.
After executing the previous subExpression the current one is executed to chek if still true. The condition checked is that the inputs is true (== 1). This function is not supported by compiled function. The return value of this function is automatically removed from the result list.
Examples: 
i=0;i=i+1;flowControlRepeatPreviousWhile (i<10);i == 10

Group: flowControl
Name: flowControlRepeatThisWhile
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: flowControlRepeatThisWhile (condition); repeats the current sub-expression while the condition is true. The condition checked is that the inputs is true (== 1). This function is not supported by compiled function. The return value of this function is automatically removed from the result list.
Examples: 
i=0;i=i+1,flowControlRepeatThisWhile (i<10);i == 10

Group: flowControl
Name: flowControlReturnThisIf
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: flowControlReturnThisIf (condition); stops the current sub-expresison evaluation returning this sub expression list if the condition is true. The condition checked is that the inputs is true (== 1). This function is not supported by compiled function. The return value of this function is automatically removed from the result list.
Examples: 
i=5;i,flowControlReturnThisIf (i<10);i=10;i == 5

Group: flowControl
Name: flowControlSkipNextIf
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: flowControlSkipNextIf (condition) skips the next sub-expression if the condition is true. The condition checked is that the inputs is true (== 1). This function is not supported by compiled function. The return value of this function is automatically removed from the result list.
Examples: 
i=5;flowControlSkipNextIf (i<10);i=10;i == 5

Group: flowControl
Name: flowControlStopHereIf
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: flowControlStopHereIf (condition) stops the current sub-expression evaluation if the condition is true. The condition checked is that the inputs is true (== 1). This function is not supported by compiled function. The return value of this function is automatically removed from the result list.

Group: fourier
Name: fourierDFT
Type: prefix function
Number of args: at least 1
Supported domain: (Complex Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: fourierDFT (list) computes the discrete fourier transform of the list. It is also applicable to plot matrix.
The discrete Fourier Transform is able to transform a list of any size from time domain to frequency domain. fourierDFT can be also used with a matrix where the first column represents the samplig times and the second the values like the one provided by standardplot. The algorithm is got from http://nayuki.eigenstate.org/res/how-to-implement-the-discrete-fourier-transform/dft.py and adapted to EngCalculator data structures by myself. To display the fourierDFT result use dataplot function. The fourierDFT is slow compared to FFT but it can operate with every size of elements.
Examples: 
fourierDFT(1,0,-1,0) == 0,2,0,2
fourierDFT(matrixTranspose([0,1,2,3],[1,0,-1,0])) == matrixTranspose([0,.25,.5,.75],[0,2,0,2])
testFourier = statisticRandom(listClone(64, 0_10));fourierDFT(testFourier) == fourierFFT(testFourier)

Group: fourier
Name: fourierDFTInverse
Type: prefix function
Number of args: at least 1
Supported domain: (Complex Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: fourierDFTInverse (list) computes the inverse discrete forier transform of the given list.
Inverse Discrete Fourier Transform is able to transform a list of any size from frequency domain to time domain. fourierDFTInverse can be also used with a matrix where the first column represents the samplig times and the second the values like the one provided by standardplot. The algorithm is got from http://nayuki.eigenstate.org/res/how-to-implement-the-discrete-fourier-transform/dft.py and adapted to IDFT and EngCalculator data structures by myself. To display the fourierDFTInverse result use dataplot function. fourierDFTInverse is much slower than FFTInverse however it can operate on any data size.
Examples: 
fourierDFTInverse(0,2,0,2) == 1,0,-1,0
fourierDFTInverse(matrixTranspose([0,.25,.5,.75],[0,2,0,2])) == matrixTranspose([0,1,2,3],[1,0,-1,0])
testFourier = statisticRandom(listClone(64, 0_10));fourierDFTInverse(testFourier) == fourierFFTInverse(testFourier)

Group: fourier
Name: fourierFFT
Type: prefix function
Number of args: at least 1
Supported domain: (Complex Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: fourierFFT (list) computes the fast fourier transform of the list. It is also applicable to plot matrix.
Fast Fourier Transform is able to transform a list of size equals to a power of 2 from time domain to frequency domain. fourierFFT can be also used with a matrix where the first column represents the samplig times and the second the values like the one provided by standardplot. The algorithm is got from http://www.cs.princeton.edu/introcs/97data/FFT.java.html and adapted to EngCalculator data structures by myself. To display the fft result use dataplot function.
Examples: 
fourierFFT(1,0,-1,0) == 0,2,0,2
fourierFFT(matrixTranspose([0,1,2,3],[1,0,-1,0])) == matrixTranspose([0,.25,.5,.75],[0,2,0,2])

Group: fourier
Name: fourierFFTInverse
Type: prefix function
Number of args: at least 1
Supported domain: (Complex Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: fourierFFTInverse (list) computes the inverse fast forier transform of the given list.
Inverse Fast Fourier Transform is able to transform a list of size equals to a power of 2 from frequency domain to time domain. fourierFFTInverse can be also used with a matrix where the first column represents the samplig times and the second the values like the one provided by standardplot. The algorithm is got from http://www.cs.princeton.edu/introcs/97data/FFT.java.html and adapted to EngCalculator data structures by myself. To display the fft result use dataplot function.
Examples: 
fourierFFTInverse(0,2,0,2) == 1,0,-1,0
fourierFFTInverse(matrixTranspose([0,.25,.5,.75],[0,2,0,2])) == matrixTranspose([0,1,2,3],[1,0,-1,0])

Group: function
Name: functionALL
Parameter: inputSizeAndDomainCheck
Value: true
Expected Input: Requires boolean value
Default: true
Help: It defines if ICE has to verify input domain and size before executing the required function.
By default the check is performed (with exception of compiled functions). Moreover disabling this check some internal error can happen. However it increases the execution speed.

Group: functionScan
Name: functionScanIntervalJoin
Type: prefix function
Number of args: at least 1
Supported domain: (Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: functionScanIntervalJoin (list) returns the smallest inteval containing all the given inputs.
It is useful if calculations were executed with interval splitted to go back to interval form.
Examples: 
functionScanIntervalJoin(1, 4, 2_7, 3, 5, 6) == 1_7
functionScanIntervalJoin(1,3,4,5) == 1_5
r1 = 10k%10, r1s  = functionScanIntervalSplitRandom r1, r2 = 20k%5, r2s = functionScanIntervalSplitRandom r2; r1/(r1+r2) >> functionScanIntervalJoin (r1s/(r1s+r2s)), 1/(1+r2/r1) >> functionScanIntervalJoin (r1s/(r1s+r2s)), r1/(r1+r2) >> 1/(1+r2/r1) == true, true, true

Group: functionScan
Name: functionScanIntervalSplitLinear
Parameter: samples
Value: 3
Expected Input: Requires integer value between 2 and 10
Default: 3
Help: The number of samples in which the interval has to be split. When new intervals are added the split increases.

Group: functionScan
Name: functionScanIntervalSplitLinear
Type: prefix function
Number of args: 2
Supported domain: (Literal,Proper Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: functionScanIntervalSplitLinear (variableName, interval) create a new variable with (variableName) made by a set of interval (3 by default) uniformly distribuited within the given interval.
 Every time a new variable is added it automatically rebuilds all the previous variables added variables so that all the possible combinations are tested in a calculus. With Join function it is possible to increase the variables. If those variable are used in reactive expression it is possible to automatically recompute all the previous values. With systemSetup ($functionScanIntervalSplitLinear, numberOfSamples) it is possible to set the default number of samples. If the functions user are linear 2 would be enough otherwise the more the better for accuracy although as the number of variables increases also the values stored in the variables increase exponentially.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
functionScanIntervalSplitLinear ($z1, 1_5, $z2, 5_7);functionScanIntervalJoin (z1/z2) == 1_5/5_7

Group: functionScan
Name: functionScanIntervalSplitRandom
Parameter: samples
Value: 1k
Expected Input: Requires interval point between 1.0 and 10000.0
Default: 1k
Help: The number of samples in which the interval is split

Group: functionScan
Name: functionScanIntervalSplitRandom
Type: prefix function
Number of args: 1
Supported domain: (Proper Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: functionScanIntervalSplitRandom (interval) split the intervals in 1000 (by default) equal points uniformely distribuited in the given interval and then arrage the sample randomly.
It is useful to evaluate expression where the same intervals is present more than one. Eventually with Join will be possible to check the result. With systemSetup ($functionScanIntervalSplitRandom, numberOfSamples) it is possible to set the default number of samples.
Examples: 
;functionScanIntervalJoin functionScanIntervalSplitRandom (1_19) == 1_19

Group: functionScan
Name: functionScanLinear
Parameter: samples
Value: 10000
Expected Input: Requires integer value between 1 and 1000000
Default: 10000
Help: The number of samples in which the interval is split

Group: functionScan
Name: functionScanLinear
Type: prefix function
Number of args: at least 2
Supported domain: (Prefix Function with at least 1 arguments,Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: functionScanLinear ($func, interval1, .., intervaln) applies the Kaucher definition for the given func at the given intervals.
For each input interval it computes the function at a number of points to run a total of 1/10 of the maximum cycles set in ICE (with stepaccuracy command) equally spaced inside each input interval. When the input interval is proper it joins the result intervals, otherwise it intersects them. That a is very slow procedure. However it may give a smaller result than standard interval arithmetic althought the resault is NOT sure because just few points of the functions are checked (it is correct for sure only if the input function is linear respect to all the input variables). For example it is not affected by the variable repetition issue: a function computing a - a will returns exactly 0. For a faster command look at randomfunctionscan, which computes the function at random points instead of using a deterministic algorithm.
Examples: 
($sum,$a,$b)='a+b';(functionScanLinear($sum,1_3,4_7),functionScanLinear($sum,1_3,7_4),functionScanLinear($sum,3_1,4_7),functionScanLinear($sum,3_1,7_4)) == (5_10,8_7,7_8,10_5)

Group: functionScan
Name: functionScanMonteCarlo
Type: prefix function
Number of args: at least 4
Supported domain: (Prefix Function with at least 1 arguments,Point Interval and Integer Interval and Positive Interval,Point Interval and Positive Interval,Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: functionScanMonteCarlo ($func, numbSimulations, numbBaskets, inputValueInterval1, .., inputValuen) runs the MonteCarlo simulation executing func on random values taken from (inputValueInterval1, .., inputValueIntervaln) for numbSimulations times and collecting the results in the given numbBaskets.
This function is limititate, for a general purpose Monte Carlo analysis see statRandomList help. functionScanMonteCarlo runs the montecarlo analysis on the input function. The output is a matrix form which can be used for plot windows. functionScanMonteCarlo requires the function to check, the number of simulation cycles, the number of baskets, and the ranges of the input values. The ranges should be espressed as intervals. A proper interval means an uniform distribution, a not proper interval means a normal distribution with average on the interval mid point and three standard deviations on the interval extremes.
Examples: 
($mul,$a)='a*a';ms = functionScanMonteCarlo($mul,10000,100,1_10); mulstat := ms; abs(calculusIntegrate($mulstat,1_100)-1)<10m == true

Group: functionScan
Name: functionScanRandom
Parameter: samples
Value: 10000
Expected Input: Requires integer value between 1 and 1000000
Default: 10000
Help: The number of random samples used within the interval.

Group: functionScan
Name: functionScanRandom
Type: prefix function
Number of args: at least 2
Supported domain: (Prefix Function with at least 1 arguments,Real Interval and Proper Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: functionScanRandom ($func, interval1, .., intervaln)  computes several times the input function on random Point Interval uniformely distribuited in the input intervals and as result provide the union of all function output.
The syntax is functionScanRandom(function name, list of intervals). That will give a smaller result than standard interval arithmetic althought it is not deterministic (the real interval result may be bigger and each execution will give slightly different result). However that function helps because interval by nature tends to provide bigger result interval than necessry. For example it is not affected by the variable repetition issue of the intervals: a function computing a - a will returns exactly 0, which is not the case of real interval. The iterations are a tenth of the maximum iterations. Work only on proper interval. For a deterministic scan algorithm see linearfunctionscan.
Examples: 
($subtract,$a)='a-a';functionScanRandom ($subtract,1_100) == 0

Group: hyperbolic
Name: hyperbolicArcCos
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: hyperbolicArcCos (interval) computes the hyperbolic inverse cos of the given interval included in 1, infinity.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
hyperbolicArcCos(1) == 0

Group: hyperbolic
Name: hyperbolicArcSin
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: hyperbolicArcSin (interval) computes the hyperbolic inverse sin of the interval.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
hyperbolicArcSin(0) == 0
;hyperbolicArcSin (123) == ;-hyperbolicArcSin (-123)

Group: hyperbolic
Name: hyperbolicArcTan
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: hyperbolicArcTan (interval) computes the hyperbolic inverse tan of the given interval in the range -1, 1.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
hyperbolicArcTan(0) == 0
;hyperbolicArcTan(0.5) == ;-hyperbolicArcTan(-0.5)

Group: hyperbolic
Name: hyperbolicCos
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: hyperbolicCos (interval) computes the hyperbolic cosine of the given interval.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
hyperbolicCos(1) == (E+1/E)/2
hyperbolicCos(0) == 1

Group: hyperbolic
Name: hyperbolicSin
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: hyperbolicSin (interval) computes the hyperbolic sin of the given interval.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
hyperbolicSin(0) == 0
hyperbolicSin(1) == (E-1/E)/2

Group: hyperbolic
Name: hyperbolicTan
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: hyperbolicTan (interval) computes the hyperbolic tan of the given interval.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
hyperbolicTan(0) == 0
hyperbolicTan(1) == hyperbolicSin 1 / hyperbolicCos 1

Group: information
Name: help
Type: prefix function
Number of args: 1
Supported domain: (Literal)
Automatically extends to list
This function is locked: cannot be changed by user
Help: help () provides the help of all the functions.
It returns all the functions staring with the literal input. Use informationFunctionList to see all the functions available also if not loaded. For a more concise output use exacthelp which provide only the exact match. Ex.: help 'sin'
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.

Group: information
Name: helpExact
Type: prefix function
Number of args: at least 1
Supported domain: (Literal)
Does not extend to list
This function is locked: cannot be changed by user
Help: helpExact provides the help of the functions matching exactly the literal provided in its input list.
For a more expanded help use 'help'. Ex.: help 'sin'.

Group: information
Name: informationAbout
Type: prefix function
Number of args: 0
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: informationAbout () prints the basic information on Engineer Calcualtor author and version.

Group: information
Name: informationExamples
Type: prefix function
Number of args: 0
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: informationExamples () prints the list of examples.

Group: information
Name: informationFeatures
Type: prefix function
Number of args: 0
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: informationFeatures () prints the list of features of Engineer Calculator.
It is useful to understand what can be done, it should be read after the instructions. A detailed help on every function is also available.

Group: information
Name: informationFunctionList
Type: prefix function
Number of args: 0
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: informationFunctionList () prints the list of features of Engineer Calculator.
It is useful to understand what can be done, it should be read after the instructions. A detailed help on every function is also available.

Group: information
Name: informationFunctionListGroup
Type: prefix function
Number of args: 1
Supported domain: (Literal)
Automatically extends to list
This function is locked: cannot be changed by user
Help: informationFunctionListGroup ('group') showes all the functions available in the given group without loading it.
The functions are separated by commas, if the request is on a super group each group is split by semicolon.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.

Group: information
Name: informationHistory
Type: prefix function
Number of args: 0
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: informationHistory () prints the list of changes made to Engineer Calculator from its beginning up to now.

Group: information
Name: informationInstructionsConsole
Type: prefix function
Number of args: 0
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: informationInstructionsConsole () provides a beginning detailed set of instruction to use Enginner Calculator console.

Group: information
Name: informationInstructionsKernel
Type: prefix function
Number of args: 0
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: informationInstructionsKernel provides a beginning detailed set of instruction to use Enginner Calculator kernel. It should be fully read to understand the how it works. After instruction it is suggested to read the 'feature' to know all the features available and then the help on each function.

Group: information
Name: informationLicense
Type: prefix function
Number of args: 0
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: informationLicense () prints the GNU GPL 3.0 licence under which is released Engineer Calculator.

Group: information
Name: informationTutorial
Type: prefix function
Number of args: 0
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: informationTutorial () prints the ICE tutorial.

Group: information
Name: informationVersion
Type: prefix function
Number of args: 0
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: informationVersion () prints the Engineer Calculator version.

Group: integer
Name: !!!
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Point Interval and Long (max 63 bit) Integer Interval)
Supported right domain: (Point Interval and Long (max 63 bit) Integer Interval)
Priority: 4, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a !!! b computes the XOR operation bit by bit between two integer point intervals a and b. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(integerFromBaseToBaseTen(2, '0011'))!!!(integerFromBaseToBaseTen(2, '0101')) == (integerFromBaseToBaseTen(2, '0110'))

Group: integer
Name: !!!
Type: prefix function
Number of args: 1
Supported domain: (Point Interval and Long (max 63 bit) Integer Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: !!! (a) is the bit operator NOT working  on a integer point interval value a.
The NOT operator works on 64 bits, the initial not written bits (at 0 to fill 64 bits) are negated as well.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
!!!(integerFromBaseToBaseTen(2, '0110011')) == integerFromBaseToBaseTen(2, '1111111111111111111111111111111111111111111111111111111111001100')

Group: integer
Name: %%%
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Point Interval and Long (max 63 bit) Integer Interval)
Supported right domain: (Point Interval and Long (max 63 bit) Integer Interval)
Priority: 10, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a %%% b compute the integer module between two integer point intervals a and b. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(127)%%%(2) == (1)

Group: integer
Name: &&&
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Point Interval and Long (max 63 bit) Integer Interval)
Supported right domain: (Point Interval and Long (max 63 bit) Integer Interval)
Priority: 4, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a &&& b computes the AND operation bit by bit between a and b.
The interval a and b has to be two integer point intervals. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(integerFromBaseToBaseTen(2, '0011'))&&&(integerFromBaseToBaseTen(2, '0101')) == (integerFromBaseToBaseTen(2, '0001'))

Group: integer
Name: ///
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Point Interval and Long (max 63 bit) Integer Interval)
Supported right domain: (Point Interval and Long (max 63 bit) Integer Interval)
Priority: 10, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a /// b computes the integer division between a and b integer point intervals. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(127)///(2) == (63)

Group: integer
Name: integerBaseTenToBase
Type: prefix function
Number of args: 2
Supported domain: (Point Interval and Long (max 63 bit) Integer Interval,Long (max 63 bit) Integer Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: integerBaseTenToBase (base, number) returns a literal representing the number (in base 10) converted to the required base.
See frombase for the opposite operation. The algorithm is taken from http://www.cs.princeton.edu/introcs/51data/Converter.java.html . Copyright © 2000–2010, Robert Sedgewick and Kevin Wayne. It is possible to apply this function to multiple arguments just adding several intervals as last parameter. 
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
integerBaseTenToBase(2, 3) == '11'
integerBaseTenToBase(10, 15) == '15'
integerBaseTenToBase(16, 29) == '1D'
integerBaseTenToBase(16, 24_29) == '18_1D'

Group: integer
Name: integerCeiling
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: integerCeiling (a) returns the smallest (closest to negative infinity) double value that is greater than or equal to the argument a and is a mathematical integer.
See also floor.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
integerCeiling(-10.7_10.7) == -10_11
integerCeiling(10.1_-5.8) == 11_-5
integerCeiling(10.99) == 11

Group: integer
Name: integerFactorial
Type: prefix function
Number of args: 1
Supported domain: (Point Interval and Long (max 63 bit) Integer Interval and Positive Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: integerFactorial (a) returns 1*2*3* .. * a.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
integerFactorial(5) == 1*2*3*4*5

Group: integer
Name: integerFactorization
Type: prefix function
Number of args: 1
Supported domain: (Point Interval and Long (max 63 bit) Integer Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: integerFactorization (a) returns the list of prima number in which can be factorized the given input a.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
integerFactorization(123) == 3,41

Group: integer
Name: integerFloor
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: integerFloor (a) returns the largest (closest to positive infinity) double value that is less than or equal to the argument a and is equal to a mathematical integer.
See also ceiling.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
integerFloor(-10.7_10.7) == -11_10
integerFloor(10.1_-5.8) == 10_-6
integerFloor(10.99) == 10

Group: integer
Name: integerFromBaseToBaseTen
Type: prefix function
Number of args: 2
Supported domain: (Point Interval and Long (max 63 bit) Integer Interval,Literal)
Automatically extends to list
This function is locked: cannot be changed by user
Help: integerFromBaseToBaseTen (base, number) returns a literal representing the number (in base 10) converted to the required base.
See tobase for the opposite operation. The algorithm is taken from http://www.cs.princeton.edu/introcs/51data/Converter.java.html . Copyright © 2000–2010, Robert Sedgewick and Kevin Wayne. It is possible to apply this function to multiple arguments just adding several intervals as last parameter. 
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
integerFromBaseToBaseTen(2, '11') == 3
integerFromBaseToBaseTen(10, '15') == 15
integerFromBaseToBaseTen(16, '1D') == 29
integerFromBaseToBaseTen(16, '18_1D') == 24_29

Group: integer
Name: integerGCD
Type: prefix function
Number of args: 2
Supported domain: (Point Interval and Long (max 63 bit) Integer Interval,Point Interval and Long (max 63 bit) Integer Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: integerGCD (a, b) returns the greatest commond divisor between a and b.
See also lcm.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
integerGCD(2, 3) == 1
integerGCD(10, 15) == 5
integerGCD(10, 20) == 10

Group: integer
Name: integerLCM
Type: prefix function
Number of args: 2
Supported domain: (Point Interval and Long (max 63 bit) Integer Interval,Point Interval and Long (max 63 bit) Integer Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: integerLCM (a, b) returns the least common multiple between a and b.
See also gcd.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
integerLCM(2, 3) == 6
integerLCM(10, 15) == 30
integerLCM(10, 20) == 20

Group: integer
Name: integerRound
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: integerRound (a) returns the closer integer to the argument a.
See also ceiling and floor.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
integerRound(-10.7_10.7) == -11_11
integerRound(10.1_-5.8) == 10_-6
integerRound(10.99) == 11

Group: integer
Name: integerRoundToDigit
Type: prefix function
Number of args: 2
Supported domain: (Point Interval and Positive Interval,Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: integerRoundToDigit (digits, a) returns the closer decimal with given number of digits to the argument a.
See also rounding, ceiling and floor.It is possible to apply this function to multiple arguments just adding several intervals as last parameter. 
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
integerRoundToDigit(1, -10.73_10.75) == -10.7_10.8
integerRoundToDigit(1, 10.11_-5.81) == 10.1_-5.8
integerRoundToDigit(1, 10.99) == 11.0

Group: integer
Name: |||
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Point Interval and Long (max 63 bit) Integer Interval)
Supported right domain: (Point Interval and Long (max 63 bit) Integer Interval)
Priority: 3, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a ||| b compute the OR operation bit by bit between two integer point intervals a and b. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(integerFromBaseToBaseTen(2, '0011'))|||(integerFromBaseToBaseTen(2, '0101')) == (integerFromBaseToBaseTen(2, '0111'))

Group: interval
Name: %
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Complex Interval)
Supported right domain: (Point Interval)
Priority: 13, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a % b generates theinterval with the value of a-a/b*100 as left exreme and a+a/b*100 as right extreme.
Can be used to add a tolerance to a list of intervals. Although this function has a very high priority, keep in mind prefix functions has higher priority than infix, therefor func a % b returns actually (func a) % b. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(2)%(4) == (2%4)
(3,4,5)%(5) == (3%5,4%5,5%5)

Group: interval
Name: +-
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Complex Interval)
Supported right domain: (Point Interval)
Priority: 13, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a +- b generates the interval a-b _ a+b.
Basically the created interval has the value of a-b as lower limit and the value of a+b as upper limit. Can be used to add a tolerance to a list of intervals. Although this function has a very high priority, keep in mind prefix functions has higher priority than infix, therefor func a +- b returns actually (func a) +- b. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(2)+-(4) == (-2_6)
(3,4,5)+-(2) == (1_5,2_6,3_7)

Group: interval
Name: _
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Point Interval)
Supported right domain: (Point Interval)
Priority: 13, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a _ b generates the interval having a as left extreme, and b as right extremes.
Although this function has a very high priority, keep in mind prefix functions has higher priority than infix, therefor func a _ b returns actually (func a) _ b. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(2)_(4) == (2_4)
(3)_(5) == (3_5)

Group: interval
Name: intervalALL
Parameter: avoidRoundings
Value: true
Expected Input: Requires boolean value
Default: true
Help: Set the rounding of ICE depending on A.
If the argument is 1, every calculus involving an interval (NOT scalar) will be outer (inner) rounded  if proper (improper) in order to be sure to cover every result (not add false result). By default this option is disabled because it avoid some basic equalities to be true (like a - dual(a) == 0) although it grants that the solution will follow interval definition.

Group: interval
Name: intervalALL
Parameter: engineerFormat
Value: true
Expected Input: Requires boolean value
Default: true
Help: Set 0 to print scientific notation or 1 to print engineer format.

Group: interval
Name: intervalALL
Parameter: matrixCellWidth
Value: 20
Expected Input: Requires integer value between 10 and 100
Default: 20
Help: Set the number of chars to use for each cell of a matrix (or vector).
If the value to print has less characters it is padded on the left with spaces, if it has more the last chars are truncated and it is added '...'

Group: interval
Name: intervalALL
Parameter: maxNumberIntervalToPrint
Value: 100
Expected Input: Requires integer value between 0 and 10000
Default: 100
Help: Set the maximum length of list to print. The value 0 stands for print all data.

Group: interval
Name: intervalALL
Parameter: nicePrint
Value: true
Expected Input: Requires boolean value
Default: true
Help: Set 1 to produce more readable output for user.
If it is set to 0 it will provide an output can be copied and pasted as new input. If nice printing is disabled all other printing settinga are ignored.

Group: interval
Name: intervalALL
Parameter: valueAndTolerance
Value: true
Expected Input: Requires boolean value
Default: true
Help: Set the print mode to intervalValue%tolerance (1) or min_max (0).

Group: interval
Name: intervalALL
Parameter: valueDigits
Value: 3
Expected Input: Requires integer value between 0 and 30
Default: 3
Help: Set the  decimal digits to print.

Group: interval
Name: intervalDirection
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: intervalDirection (A) returns -1, if A is an improper directed interval; 1, if A is proper or degenerate and 0, if A involves NaN.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
intervalDirection(-10_10) == 1
intervalDirection(10_-5) == -1
intervalDirection(10_10) == 1

Group: interval
Name: intervalDistance
Type: prefix function
Number of args: 2
Supported domain: (Real Interval,Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: intervalDistance (A, B) computes the distance between intervals A and B.
It is the maximum between the absolute difference for their extreme points.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
intervalDistance(-10_10, 3_4) == 13
intervalDistance(10_-5, 3_4) == 9
intervalDistance(10_10, 3_4) == 7

Group: interval
Name: intervalDual
Type: prefix function
Number of args: 1
Supported domain: (Complex Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: intervalDual (A_B) conjugates of the directed interval A_B which is B_A.
It basically means to exchange the extreme points.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
intervalDual(-10_10) == 10_-10
intervalDual(-10_-5) == -5_ -10
intervalDual(10_15) == 15_10

Group: interval
Name: intervalExtremes
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: intervalExtremes (A_B) return (A, B).
It basically returns a list with the first and second end point of an interval.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
intervalExtremes(1%4) == (0.960, 1.04)

Group: interval
Name: intervalIsLiteral
Type: prefix function
Number of args: 1
Supported domain: (Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: intervalIsLiteral (A) returns true if the interval is literal
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
intervalIsLiteral(1_10) == false
intervalIsLiteral('1_10') == true
intervalIsLiteral(10_10) == false
intervalIsLiteral(10_1) == false

Group: interval
Name: intervalIsPoint
Type: prefix function
Number of args: 1
Supported domain: (Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: intervalIsPoint (A) returns true if the interval is point
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
intervalIsPoint(1_10) == false
intervalIsPoint('1_10') == false
intervalIsPoint(10_10) == true
intervalIsPoint(10_1) == false

Group: interval
Name: intervalIsProper
Type: prefix function
Number of args: 1
Supported domain: (Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: intervalIsProper (A) returns true if the interval is proper
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
intervalIsProper(1_10) == true
intervalIsProper('1_10') == false
intervalIsProper(10_10) == true
intervalIsProper(10_1) == false
intervalIsProper(1_10+I* 1_10) == true
intervalIsProper(1_10+I* 10_1) == false

Group: interval
Name: intervalIsReal
Type: prefix function
Number of args: 1
Supported domain: (Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: intervalIsReal (A) returns true if the interval is real
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
intervalIsReal(1_10) == true
intervalIsReal('1_10') == false
intervalIsReal(10_10) == true
intervalIsReal(10_1) == true
intervalIsReal(1+I*1) == false

Group: interval
Name: intervalLeft
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: intervalLeft (A_B) return A.
It basically returns the left extreme of the interval.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
intervalLeft(0_10, 5_10) == 0, 5

Group: interval
Name: intervalModule
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: intervalModule (A) computes the module of the interval A.
It is a real value. The interval module is defined as the maximum of the absolute value of the extremes.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
intervalModule(-10_10) == 10
intervalModule(-10_-5) == 10
intervalModule(10_15) == 15
intervalModule(10_-10) == 10
intervalModule(-5_-10) == 10
intervalModule(15_10) == 15

Group: interval
Name: intervalProper
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: intervalProper (A) returns proper part (projection) of the directed interval A.
It is A if A is proper and dual(A) is A is not proper.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
intervalProper(-10_10) == -10_10
intervalProper(10_-5) == -5_10
intervalProper(10_-10) == -10_10

Group: interval
Name: intervalRange
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: intervalRange (a) computes the range of the interval a.
It is the right side minus the left one.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
intervalRange(1_10, 5_12) == 9, 7
intervalRange(3_1) == -2

Group: interval
Name: intervalRight
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: intervalRight (a_b) returns b.
It returns the right extreme of an interval.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
intervalRight(0_10, 5_12) == 10, 12

Group: interval
Name: intervalTolerance
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: intervalTolerance (a%b) returns b.
It computes the tolerance on every interval of a list of intervals.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
intervalTolerance(1%10, 5.10%2) == 10, 2

Group: interval
Name: intervalValue
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: intervalValue (a%b) return a.
It computes the value on every interval of a list of intervals.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
intervalValue(1%10, 5.10%2) == 1, 5.10

Group: interval
Name: intervalValueTolerance
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: intervalValueTolerance (a%b) returns (a, b).
It computes the value and tolerance on every interval of a list of intervals.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
intervalValueTolerance(0_10, 5_10) == 5, 100, 7.5, 33.333

Group: interval
Name: sign
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: sign (A) returns the A sign.
It means to return -1, if A contains only negative values and 0; 1, if A contains only positive values and 0; 0 if A contains both positive and negative values or A is 0 or A involves NaN.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
sign(-10_10, 5_7, -7_-5) == 0, 1, -1

Group: list
Name: ,
Type: infix function
Number of left args:  variable
Number of right args:  at least 1
Supported left domain: (Interval)
Supported right domain: (Interval)
Priority: 0, Min Priority: 0, Max Priority: 13
Associativity: left to right
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: a , b returns the list (a, b).
It gets two separate intervals to make a list of intervals. It works to joins two matrices, first try to joins by row (if they have the same number of rows), then by column (if the have the same number of column). To join by column when the number of row is the same see the command ,| or brake the matrices in two lists with #0, join the lists, eventually make again the matrices.
Examples: 
(6_7),(4_5) == (6_7,4_5)
(1_2,3_4),(5_6) == (1_2, 3_4, 5_6)
((1,2)#1),((3,4)#1) == ((1,3,2,4)#2)
([1,2],[3,4]),([5],[6]) == ([1,2,5],[3,4,6])
([1,2],[3,4]),([1,2],[3,4]) == ([1,2,1,2],[3,4,3,4])
(a=(1,2);b=(3,a,4)) == (3,1,2,4)
(a={1,2};b=(3,a,4)) == (3,{1,2},4)
(;(1,2)+(3,4,5,6)) == (1+3,2+4,1+5,2+6)
(;(1)+(3,4,5,6)) == (1+3,1+4,1+5,1+6)

Group: list
Name: ..
Type: infix function
Number of left args:  variable
Number of right args: 1
Supported left domain: (Point Interval and Integer Interval)
Supported right domain: (Point Interval and Integer Interval)
Priority: 12, Min Priority: 0, Max Priority: 13
Associativity: left to right
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: a .. b returns the integer list from a to b.
.. is thought to build a list of integer numbers to be used to get intervals from list. If .. is applied two a couple of integers it returns a list going from the first to the last element. If .. is applied to a list and an integer it gets the value from the list reading with the given step.
Examples: 
(2)..(6) == (2, 3, 4, 5, 6)
(6)..(4) == (6,5,4)
(1;1 .. 10 .. 2) == (1,3,5,7,9)

Group: list
Name: ::
Type: infix function
Number of left args:  variable
Number of right args:  at least 1
Supported left domain: (everything)
Supported right domain: (everything)
Priority: 12, Min Priority: 0, Max Priority: 13
Associativity: left to right
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: (list) :: 8index1, index2, ..) returns the element of the list at the given indexes.
Given a list :: is able to extract a set of values of the list pointed by the given indexes. The first element of the list has index 0. If an index is a range then the values from interval left to interval right (inclusive) are extracted. If the interval is not proper the values are extracted from the end toward the beginning. If an index is negative it is summed to the length of the list: therefore -1 is the last element, -2 the element before the last and so on. Given a matrix the '::' is able to extract an element of the list which is given by the interval rowstart_rowend, columnstart_columnend. A matrix is read left to right, up to down, row by row starting from element 0 up-left. If instead of row or column a negative number is given the count begin from the end.
Examples: 
((1,2,3,4,5,6,7,8,9)#3)::(0_1,0_1) == ((1,2,4,5)#2)
((1,2,3,4,5,6,7,8,9)#3)::(1_0,0_1) == ((4,5,1,2)#2)
((1,2,3,4,5,6,7,8,9)#3)::(0_1,1_0) == ((2,1,5,4)#2)
((1,2,3,4,5,6,7,8,9)#3)::(1_0,1_0) == ((5,4,2,1)#2)
((1,2,3,4,5,6,7,8,9)#3)::(0_1,0_1,1_2,1_2) == ((1,2,5,6,4,5,8,9)#4)
((1,2,3,4,5,6,7,8,9)#3)::(0_-1,0_-1) == ((1,2,3,4,5,6,7,8,9)#3)
(1,2,3)::(1) == (2)
(1,2,3,4)::(1,3) == (2,4)
(1,2,3,4)::(0,0,1) == (1,1,2)
((1,2,3,4)#2)::(0_1,1) == ((2,4)#1)
((1,2,3,4)#2)::(1_0,0) == ((3,1)#1)
((1,2,3,4)#2)::(1,0_1) == ((3,4)#2)
(1,2,3,4,5,6,7,8,9)::(3 .. 6) == (4,5,6,7)
(1,2,3,4,5,6,7,8,9)::(3 .. 6 .. 2) == (4,6)
(1,2,3,4,5,6,7,8,9)::(3, 6) == (4,7)
(1,2,3,4,5,6,7,8,9)::(3_5) == (4,5,6)
(1,2,3,4,5,6,7,8,9)::(6_-1) == (7,8,9)
(1,2,3,4,5,6,7,8,9)::(3_0) == (4,3,2,1)
(;(1,2,{3,4,{5,6},7},8) :: 2 :: (1,3)) == (4,7)
(;(1,2,{3,4,{5,6},7},8) :: 2 :: 2 :: 0_-1) == (5,6)
(;(1,2,{3,4,{5,6},7},8) :: 2 :: 2) == ({5,6})
(;(1,2,{3,4,{5,6},7},8) :: 2) == ({3,4,{5,6},7})

Group: list
Name: ::=
Type: infix function
Number of left args:  variable
Number of right args:  at least 1
Supported left domain: (everything)
Supported right domain: (everything)
Priority: 1, Min Priority: 0, Max Priority: 13
Associativity: right to left
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: (list) ::= (index, value, index2, value2, ..) in the given lists (or variable) it sets the required value at the given index.
Given a list ::= is able to set some values of the list pointed by the given indexes at the given values. The first element of the list has index 0. If an index is a range then the values from interval left to interval right (inclusive) are set. If the interval is not proper the values are set from the end toward the beginning. If an index is negative it is summed to the length of the list: therefore -1 is the last element, -2 the element before the last and so on. Given a matrix the '::=' is able to set some elements of the list which are given by the interval rowstart_rowend, columnstart_columnend. A matrix is read left to right, up to down, row by row starting from element 0 up-left. If instead of row or column a negative number is given the count begin from the end.
Examples: 
((1 .. 9)#3)::=(0_1,0_1, 11 .. 14) == ((11,12,3,13, 14,6,7,8,9)#3)
((1 .. 9)#3)::=(1_0,0_1, 11,12,14,15) == ((14,15,3,11,12,6,7,8,9)#3)
((1 .. 9)#3)::=(0_1,1_0, 11,12,14,15) == ((12,11,3,15,14,6,7,8,9)#3)
((1 .. 9)#3)::=(1_0,1_0, 11,12,14,15) == ((15,14,3,12,11,6,7,8,9)#3)
((1 .. 9)#3)::=(0_-1,0_-1, 2 .. 10) == ((2,3,4,5,6,7,8,9, 10)#3)
(1,2,3)::=(1,12) == (1,12,3)
(1,2,3,4)::=(1,12,3,14) == (1,12,3,14)
(1,2,3,4)::=(0,1,0,2,1,3) == (2,3,3,4)
((1 .. 4)#2)::=(0_1,1,12,14) == ((1,12,3,14)#2)
((1 .. 4)#2)::=(1_0,0,11,13) == ((13,2,11,4)#2)
((1 .. 4)#2)::=(1,0_1,13,14) == ((1,2,13,14)#2)
(1 .. 9)::=(3_6, 14 .. 17) == (1,2,3,14,15,16,17,8,9)
(1 .. 9)::=(3, 14, 6, 17) == (1,2,3,14,5,6,17,8,9)
(1 .. 9)::=(3_5, 14 .. 16) == (1,2,3,14,15,16,7,8,9)
(1 .. 9)::=(6_-1, 17 .. 19) == (1,2,3,4,5,6,17,18,19)
(1 .. 9)::=(3_0, 11 .. 14) == (14,13,12,11,5,6,7,8,9)
(1,2,{3,4},5)::=(2, 2) == (1,2, 2,5)
(1,2,{3,4},5)::=(2, {1,2}) == (1,2,{1,2},5)
(1,2,{3,4},5)::=(2, {1,2,3}) == (1,2,{1,2,3},5)
({1,2,3,4})::=(2,5) == ({1,2,5,4})

Group: list
Name: ?
Type: infix function
Number of left args:  variable
Number of right args:  at least 1
Supported left domain: (Interval)
Supported right domain: (Logic Interval)
Priority: 2, Min Priority: 0, Max Priority: 13
Associativity: right to left
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: (list) ? (boolean list) return the (list) elements whose correspondig (boolean list) elements are != 0.
 ? with trueIf the right side of ? is true (1) it returns its left side, otherwise it does not return anything. It is useful to extract elements from a list.
Examples: 
((testkit = 1 .. 10); testkit ? (testkit > 5)) == (6 .. 10)

Group: list
Name: listClone
Type: prefix function
Number of args: 2
Supported domain: (Point Interval and Integer Interval and Positive Interval,Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: listClone (number of clones, interval) returns (interval, interval, interval, ..).
It generates a new list containing the given number of the input interval.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
listClone(3, 4_1+2*I) == (4_1+2*I, 4_1+2*I, 4_1+2*I)
listClone(4,{1,2,3}) == {1,2,3},{1,2,3},{1,2,3},{1,2,3}

Group: list
Name: listCombination
Type: prefix function
Number of args: at least 1
Supported domain: ({Interval List of []})
Automatically extends to list
This function is locked: cannot be changed by user
Help: listCombination ({a1, a2, ..}, {b1, b2, ..}, {c1, c2, ..}) returns all the possible combinations (a1, b1, c1, a1, b1, c2, ..).
It returns  give a list of sub-list it provides a list containing all the possible combination (taking one element from each sub-list) of the given sub-lists.
Examples: 
listCombination({1,2},{3,4},{5,6}) == 1,3,5,1,3,6,1,4,5,1,4,6,2,3,5,2,3,6,2,4,5,2,4,6

Group: list
Name: listDistance
Type: prefix function
Number of args: 2
Supported domain: ({Interval List of []},{Interval List of []})
Automatically extends to list
This function is locked: cannot be changed by user
Help: listDistance (intervalA, intervalB) returns the distance between the given itnervals.
It computes the distance between two {sub-lists}, which is the sum of the distances between each couple of intervals, which is the maximum between the absolute difference for their extreme points.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
listDistance({-10_10, 10_-5, 10_10},{3_4, 3_4, 3_4}) == 13+9+7

Group: list
Name: listFlatten
Type: prefix function
Number of args: at least 1
Supported domain: (everything)
Automatically extends to list
This function is locked: cannot be changed by user
Help: listFlatten ({a, b}, {c}, d, {e, f}) returns a flat list (a,b,c,d,e,f).
It takes a list of element (usually sub-list nested) it create a single list containing all the elements.
Examples: 
listFlatten(0,{1,{2,3},{4,5,{6,7,{8}},9},10},11,12) == 0 .. 12

Group: list
Name: listGrow
Type: prefix function
Number of args: 3
Supported domain: (Point Interval and Integer Interval and Positive Interval,Point Interval and Integer Interval and Positive Interval,{Interval List of []})
Does not extend to list
This function is locked: cannot be changed by user
Help: listGrow (size, clone, {list}) return a new list obtained from elements of list at group of size cloned clone times.
It gets the group size, the number of copies of each group and a {sub-list}. Return a new list where the number of groups were copied for the given times. For example suppose you have the following foundamental frequencies found = (100, 500, 600,900) and you want to make a new list with the foundamental plus the first 4 harmonics you can achieve with this: listGrow (1,4,found)* listGrow(4,4, 1 .. 4).
Examples: 
listGrow(3, 2, {1 .. 6}) == 1 .. 3, 1 .. 3, 4 .. 6, 4 .. 6

Group: list
Name: listIncremental
Type: prefix function
Number of args: 3
Supported domain: (Point Interval and Integer Interval and Positive Interval,Real Interval,Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: listIncremental (noi, increment, start) generates a list of noi intervals from start with given increment.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
listIncremental(4, 2, 10) == (10, 12, 14, 16)

Group: list
Name: listIndexOf
Type: prefix function
Number of args: at least 2
Supported domain: (Prefix Function with 1 arguments,Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: listIndexOf (test_function, list) returns the indexes of the list for which the test_function returns true.
The result list can be used with :: and ::= to get or manipolate those elements.
Examples: 
listIndexOf(defineLambdaFunction ('$x>5'), listShuffle({1 .. 5},{6 .. 10})) == 1 .. 10 .. 2
test=1 .. 10;test :: (listIndexOf( defineLambdaFunction ('$x>5'), test)) == test ? (test>5)

Group: list
Name: listInteger
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: listInteger (A_B) build a list of integer number between the floor of interval min (A) and the floor of interval max (B).
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
listInteger(2_5) == 2, 3, 4, 5
listInteger(4_3) == 4,3

Group: list
Name: listLinear
Type: prefix function
Number of args: 2
Supported domain: (Point Interval and Integer Interval and Positive Interval,Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: listLinear (nOfIntervals, begin_eng) produces a list of nOfIntervals intervals linearly spaced from the minimum to the maximum of the given interval.
Syntax: listLinear (number of points, interval). It is very useful to compute a function at several points.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
listLinear(5, 1_9) == (1, 3, 5, 7, 9)
listLinear(4, 3) == (3,3,3,3)

Group: list
Name: listLogarithmic
Type: prefix function
Number of args: 2
Supported domain: (Point Interval and Integer Interval and Positive Interval,Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: listLogarithmic (nOfIntervals, begin_eng) produces a list of nOfIntervals intervals logarithmically spaced from the minimum to the maximum of the given interval.
Syntax: listLogarithmic (number of points, interval). It is very useful to compute a function at several points.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
listLogarithmic(5, 10_1G) == 10, 1k, 100k, 10M, 1G

Group: list
Name: listPick
Type: prefix function
Number of args: at least 2
Supported domain: ({Interval List of [Integer Interval]},Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: listPick ({index1, index2, index3, .., indexn, module}, list element) pick index1, index2, index3, indexn every module elment of the following list.
Examples: 
listPick({0,2},1 .. 6) == 1,3,5
listPick({1,2},1 .. 6) == 2,4,6

Group: list
Name: listShuffle
Type: prefix function
Number of args: at least 1
Supported domain: ({Interval List of []})
Automatically extends to list
This function is locked: cannot be changed by user
Help: listShuffle ({a1, a2, .., an}, {b1, b2, .. bn}, ..) returns the list made by (a1, b1, c1, .., a2, b2, c2, .. )
.The first element of each gets several {sub-lists} (of the same size). It return a list obtained taking the first element of each list, then the second, and so on.
Examples: 
listShuffle({1 .. 3}, {4 .. 6}) == 1,4,2,5,3,6

Group: list
Name: listSize
Type: prefix function
Number of args: at least 1
Supported domain: (Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: listSize (a1, a2, .., an) returns n.
It returns the number of intervals content in a list.
Examples: 
listSize(-10_-2, 5_7, -7_-5) == 3

Group: literal
Name: literalCharJoin
Type: prefix function
Number of args: at least 1
Supported domain: (Literal)
Does not extend to list
This function is locked: cannot be changed by user
Help: literalCharJoin (lit1, lit2, .. litn) returns a literal made by the concatenation of all the given ones.
Examples: 
literalCharJoin(literalCharSplit('home')) == 'home'

Group: literal
Name: literalCharSplit
Type: prefix function
Number of args: 1
Supported domain: (Literal)
Automatically extends to list
This function is locked: cannot be changed by user
Help: literalCharSplit ('literal') returns the list of literals (chars) which compose the given literal: 'l','i', .,'l'.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
literalCharSplit('home') == 'h','o','m','e'

Group: literal
Name: literalFromExpression
Type: prefix function
Number of args: at least 1
Supported domain: (Point Interval and Integer Interval and Positive Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: literalFromExpression (value) return the given value as a literal 'value'.
Note value may be a complex expression. If the value is a list of intervals, it returns a single string containing all the list as string. If the single values should be returned in a list use literalFromInterval.
Examples: 
literalFromExpression(literalToExpression('(1+1)/2')) == '1'

Group: literal
Name: literalFromInterval
Type: prefix function
Number of args: 1
Supported domain: (Complex Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: literalFromInterval (interval1, .., intervaln) return the given values as a literal: 'interval1', .. ,'intervaln'.
Compared to literal from expression it would return a list of literal given a list of intervals.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
literalFromInterval((1,2,3,PI)) == '1','2','3','3.142'

Group: literal
Name: literalFromIntervalDetailed
Type: prefix function
Number of args: 1
Supported domain: (Complex Interval or {Interval List of []})
Automatically extends to list
This function is locked: cannot be changed by user
Help: literalFromIntervalDetailed (interval1, .., intervaln) return the given values as a literal: 'interval1', .. ,'intervaln'.
Compared to literal from interval it prints the output with all the internal accuracy and in the same way in which they can be entered again as new input: the same would be showed with nicePrint off. It is useful to see an interval with full details without changing the print settings.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
literalFromIntervalDetailed(PI) == '3.141592653589793'

Group: literal
Name: literalFromUnicode
Type: prefix function
Number of args: at least 1
Supported domain: (Point Interval and Integer Interval and Positive Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: literalFromUnicode (unicode1, unicode2, .. unicodeN) returns the characters with the given unicode number.
Examples: 
literalFromUnicode(literalToUnicode('home')) == 'home'

Group: literal
Name: literalRegularExpressionFind
Type: prefix function
Number of args: at least 2
Supported domain: (Literal,Literal)
Does not extend to list
This function is locked: cannot be changed by user
Help: literalRegularExpressionFind ('regular expression', literal) looks for sub-literals matching the regular expression within the input literal and returns them.
It is possible to apply to several literals. For regular expression syntax see literalRegularExpressionMatch help.
Examples: 
literalRegularExpressionFind('\w+man', 'ironman,hulk,spiderman,superman,mr.incredible') == 'ironman','spiderman','superman'

Group: literal
Name: literalRegularExpressionMatch
Type: prefix function
Number of args: at least 2
Supported domain: (Literal,Literal)
Does not extend to list
This function is locked: cannot be changed by user
Help: literalRegularExpressionMatch ('regular expression', lit2, .. litn) returns true for each literal matching the given Java regular expression, false otherwise.
Used in conjunction with ? can select from a list only the literal matching it. For example it can be used to unlock a group. For instance to unlock the group decibel: defineLockClear (defineShowAllFunctions ? (literalMatch('decibel.*',defineShowAllFunctions )))A short explanation of Java Regular Expression follows.
Java Regular Expression Description: . Matches any character; ^regex Finds regex that must match at the beginning of the line; regex$ 	Finds regex that must match at the end of the line; [abc] Set definition; can match the letter a or b or c; [abc][vz] Set definition, can match a or b or c followed by either v or z; [^abc] When a caret appears as the first character inside square brackets, it negates the pattern; This can match any character except a or b or c; [a-d1-7] Ranges: matches a letter between a and d and figures from 1 to 7, but not d1; X|Z Finds X or Z; XZ 	Finds X directly followed by Z; $ Checks if a line end follows.
Metacharacters: The following metacharacters have a pre-defined meaning and make certain common patterns easier to use, e.g., \d instead of [0..9]; Regular Expression 	Description: \d Any digit, short for [0-9]; \D A non-digit, short for [^0-9]; \s A whitespace character, short for [ \t\n\x0b\r\f]; \S A non-whitespace character, short for [^\s]; \w A word character, short for [a-zA-Z_0-9]; \W A non-word character [^\w]; \S+ Several non-whitespace characters; \b Matches a word boundary where a word character is [a-zA-Z0-9_].
Quantifier: A quantifier defines how often an element can occur. The symbols ?, *, + and {} define the quantity of the regular expressions. Regular Expression 	Description Examples: * Occurs zero or more times, is short for {0,} X* finds no or several letter X,; .* finds any character sequence; + Occurs one or more times, is short for {1,} X+ - Finds one or several letter X; ? Occurs no or one times, ? is short for {0,1}. X? finds no or exactly one letter X; {X} Occurs X number of times, {} describes the order of the preceding liberal \d{3} searches for three digits, .{10} for any character sequence of length 10; {X,Y} Occurs between X and Y times, \d{1,4} means \d must occur at least once and at a maximum of four; *? ? after a quantifier makes it a reluctant quantifier. It tries to find the smallest match.
Grouping and Backreference: You can group parts of your regular expression. In your pattern you group elements with round brackets, e.g., (). This allows you to assign a repetition operator to a complete group. 
Negative Lookahead provides the possibility to exclude a pattern. With this you can say that a string should not be followed by another string. Negative Lookaheads are defined via (?!pattern). For example, the following will match "a" if "a" is not followed by "b". a(?!b)
Examples: 
literalRegularExpressionMatch('.*man', 'ironman', 'hulk', 'spiderman') == true, false, true

Group: literal
Name: literalRegularExpressionSplit
Type: prefix function
Number of args: at least 2
Supported domain: (Literal,Literal)
Does not extend to list
This function is locked: cannot be changed by user
Help: literalRegularExpressionSplit ('regular expression', literal) looks for regular expression within the literal and returns the literals without them.
It is possible to apply to several literals. For regular expression syntax see literalRegularExpressionMatch help.
Examples: 
literalRegularExpressionSplit(',', 'ironman,hulk,spiderman,superman,mr.incredible') == 'ironman','hulk','spiderman','superman','mr.incredible'

Group: literal
Name: literalToExpression
Type: prefix function
Number of args: 1
Supported domain: (Literal)
Automatically extends to list
This function is locked: cannot be changed by user
Help: literalToExpression ('expression') evaluate the ICE expression and returns its result.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
literalToExpression(literalFromExpression(1 .. 10)) == 1 .. 10

Group: literal
Name: literalToUnicode
Type: prefix function
Number of args: 1
Supported domain: (Literal)
Automatically extends to list
This function is locked: cannot be changed by user
Help: literalToUnicode ('literal') returns the list of unicode values to made its chars.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
literalToUnicode(literalFromUnicode(105 .. 110)) == 105 .. 110

Group: logarithm
Name: ln
Type: prefix function
Number of args: 1
Supported domain: (Not Interval 0.0)
Automatically extends to list
This function is locked: cannot be changed by user
Help: ln (a) computes the natural logarithm of the interval a.
Accept complex arguments.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
ln(E) == 1
;exp ln -5 == -5
;exp ln (10+5*I) == (10+5*I)

Group: logarithm
Name: log
Type: prefix function
Number of args: 1
Supported domain: (Not Interval 0.0)
Automatically extends to list
This function is locked: cannot be changed by user
Help: log (a) computes the logarithm base 10 of the interval a.
Accept complex arguments.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
log(10) == 1

Group: logarithm
Name: logBase
Type: prefix function
Number of args: 2
Supported domain: (Positive Interval and Point Interval and Not Interval 0.0,Positive Interval and Not Interval 0.0)
Automatically extends to list
This function is locked: cannot be changed by user
Help: logBase (base, a) computes the logarithm of the interval a with base.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
logBase(10, 10, 3, 3, 5,25) == 1, 1, 2

Group: logic
Name: !!
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Logic Interval)
Supported right domain: (Logic Interval)
Priority: 4, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a !! b returns the logic XOR between the intervervals (or lists) a and b.
!! returns true if the inputs (trueFalse excluse) are different, if any of the input is trueFalse it returns trueFalse. In ICE logic 0 is false, 1 is true, 0_1 may be true or false. The constants true, false and truefalse are defined. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(true)!!(true) == (false)
(true)!!(trueFalse) == (trueFalse)
(true)!!(false) == (true)
(trueFalse)!!(true) == (trueFalse)
(trueFalse)!!(trueFalse) == (trueFalse)
(trueFalse)!!(false) == (trueFalse)
(false)!!(true) == (true)
(false)!!(trueFalse) == (trueFalse)
(false)!!(false) == (false)

Group: logic
Name: !!
Type: prefix function
Number of args: 1
Supported domain: (Logic Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: !! (a) returns the logic operator NOT operator applied on the interval a.
It works on a three state logic: true (1), false (0) and turefalse (0_1). !! return true for false and vice versa, it returns true_false for true_false.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
!!(1) == 0
!!(0) == 1
!!(1,0_1,1,0,0) == 0,0_1,0,1,1

Group: logic
Name: &&
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Logic Interval)
Supported right domain: (Logic Interval)
Priority: 4, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a && b compute the logic AND between two intervals a and b.
It returns false if a or b is false, true if both are true, trueFalse otherwise. In ICE logic 0 is false, 1 is true, 0_1 may be true or false. The constants true, false and truefalse are defined. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(true)&&(true) == (true)
(true)&&(trueFalse) == (trueFalse)
(true)&&(false) == (false)
(trueFalse)&&(true) == (trueFalse)
(trueFalse)&&(trueFalse) == (trueFalse)
(trueFalse)&&(false) == (false)
(false)&&(true) == (false)
(false)&&(trueFalse) == (false)
(false)&&(false) == (false)

Group: logic
Name: false
Type: variable
This variable is locked: cannot be changed by user
Help: It is the value 0 and represents the logic value false.

Group: logic
Name: true
Type: variable
This variable is locked: cannot be changed by user
Help: In ICE logic the value 1 is true.

Group: logic
Name: trueFalse
Type: variable
This variable is locked: cannot be changed by user
Help: In ICE the value 0_1 is called trueFalse and means something that may be true or false.

Group: logic
Name: ||
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Logic Interval)
Supported right domain: (Logic Interval)
Priority: 3, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a || b computes the logic OR between the intervals (or lists) a and b.
|| returns true if any of the input is true, false if all are false, trueFalse otherwise. In ICE logic 0 is false, 1 is true, 0_1 may be true or false. The constants true, false and truefalse are defined. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(true)||(true) == (true)
(true)||(trueFalse) == (true)
(true)||(false) == (true)
(trueFalse)||(true) == (true)
(trueFalse)||(trueFalse) == (trueFalse)
(trueFalse)||(false) == (trueFalse)
(false)||(true) == (true)
(false)||(trueFalse) == (trueFalse)
(false)||(false) == (false)

Group: matrix
Name: #
Type: infix function
Number of left args:  variable
Number of right args: 1
Supported left domain: (everything)
Supported right domain: (Real Interval)
Priority: 13, Min Priority: 0, Max Priority: 13
Associativity: left to right
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: (list) # columns : given the list and the number of columns of the matrix '#' builds up a matrix displacing the elements of the list in the rows of the matrix.
If the value is zero (and the list is a matrix) the matrix is transfomed in a list.
Examples: 
(5,6,7,8)#(4) == ([5,6,7,8])
(5,6,7,8)#(4_0) == ([5,6,7,8])
(5,6,7,8)#(0_4) == ([5],[6],[7],[8])
([1,2],[3,4])#(0) == (1,2,3,4)
('a','b','c')#(1) == (['a'],['b'],['c'])

Group: matrix
Name: **
Type: infix function
Number of left args:  variable
Number of right args:  at least 1
Supported left domain: (everything)
Supported right domain: (everything)
Priority: 10, Min Priority: 0, Max Priority: 13
Associativity: left to right
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: [matA ** [matB] multiply the matrix matA for the matrix matB row by columns as per Kaucher arithmetic. This function can be also applied to a set of sublist of ({matrixL1}, {matrixL2}, ..) ** ({matrixR1}, {matrixR2}, ..)
Examples: 
((1,2,3,4)#2)**((5,6,7,8)#2) == ((19,22,43,50)#2)

Group: matrix
Name: ,|
Type: infix function
Number of left args:  variable
Number of right args:  at least 1
Supported left domain: (everything)
Supported right domain: (everything)
Priority: 0, Min Priority: 0, Max Priority: 13
Associativity: left to right
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: [matA] ,|  [matB] joins two matrices by column.
This command can usually be replaced by ',' which makes the more significant action. However if the matrices have same rows and column ',' would always join by row, which may no be the right thing to do.
Examples: 
(6_7),|(4_5) == ((6_7,4_5)#1)
(1_2,3_4),|(5_6,7_8) == ((1_2, 3_4, 5_6, 7_8)#2)
((1,2)#1),|((3,4)#1) == ((1,2,3,4)#1)

Group: matrix
Name: //
Type: infix function
Number of left args:  variable
Number of right args:  at least 1
Supported left domain: (everything)
Supported right domain: (everything)
Priority: 10, Min Priority: 0, Max Priority: 13
Associativity: left to right
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: [matA] // [matB] returns the division between square matrices matA and matB.
Internalli it actually perform the inversion of matB and their multiplication. Uses JAMA library. This function can be also applied to a set of sublist of ({matrixL1}, {matrixL2}, ..) // ({matrixR1}, {matrixR2}, ..)
Examples: 
([3,4],[6,9])//([3,4],[6,9]) == ([1,0],[0,1])

Group: matrix
Name: ^^
Type: infix function
Number of left args:  variable
Number of right args: 1
Supported left domain: Square matrix: (Point Interval)
Supported right domain: (Point Interval)
Priority: 11, Min Priority: 0, Max Priority: 13
Associativity: right to left
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: mat ^^ p returns the given square matrix mat rised to the power p.
Use eigen value/vector decomposition: A^n = VEC * VAL^n * VEC^-1. Uses JAMA library.
Examples: 
([3,4],[6,9])^^(3) == (([3,4],[6,9])**([3,4],[6,9])**([3,4],[6,9]))

Group: matrix
Name: matrixDeterminant
Type: prefix function
Number of args: at least 1
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: matrixDeterminant [matA] returns the determinant of the given square matrix matA. Uses JAMA library. This function can be also applied to a set of sublist of ({matrix1}, {matrix2}, ..)
Examples: 
matrixDeterminant((2.5,3,4,6)#2) == 3

Group: matrix
Name: matrixDiagonal
Type: prefix function
Number of args: at least 2
Supported domain: (Complex Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: matrixDiagonal (list) builds a diagonal matrix with given list in its diagonal.
Examples: 
matrixDiagonal(1,2) == (1,0,0,2)#2

Group: matrix
Name: matrixEigenValue
Type: prefix function
Number of args: at least 1
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: matrixEigenValue [mat] returns the eigen value matrix of the given square matrix mat.
Uses JAMA library. This function can be also applied to a set of sublist of ({matrix1}, {matrix2}, ..)
Examples: 
vec = matrixEigenVector((13,5,2,4)#2);val=matrixEigenValue((13,5,2,4)#2);vec ** val ** matrixInvert(vec) == (13,5,2,4)#2

Group: matrix
Name: matrixEigenVector
Type: prefix function
Number of args: at least 1
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: matrixEigenVector [mat] returns the eigen vector matrix of the given square matrix mat.
Uses JAMA library. This function can be also applied to a set of sublist of ({matrix1}, {matrix2}, ..)
Examples: 
vec = matrixEigenVector((13,5,2,4)#2);val=matrixEigenValue((13,5,2,4)#2);vec ** val ** matrixInvert(vec) == (13,5,2,4)#2

Group: matrix
Name: matrixIdentity
Type: prefix function
Number of args: 1
Supported domain: (Point Interval and Integer Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: matrixIdentity (size) builds an identity matrix of required size.
Examples: 
matrixIdentity(2) == (1,0,0,1)#2

Group: matrix
Name: matrixInvert
Type: prefix function
Number of args: at least 1
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: matrixInvert [mat] returns the inverse of the given matrix mat.
Uses JAMA library. This function can be also applied to a set of sublist of ({matrix1}, {matrix2}, ..)
Examples: 
mat=statisticRandom(listClone(9,0_100))#3;mat**matrixInvert(mat) == matrixIdentity(3)

Group: matrix
Name: matrixLINE
Type: variable
This variable is locked: cannot be changed by user
Help: matrixLINE returns the interval 0_-1 which can be used to select an entire row or column for extraction.

Group: matrix
Name: matrixMaker
Type: prefix function
Number of args: 3
Supported domain: (Point Interval and Positive Interval and Integer Interval,Point Interval and Positive Interval and Integer Interval,Prefix Function with 2 arguments)
Does not extend to list
This function is locked: cannot be changed by user
Help: matrixMaker (rows, columns, f(r,c)) builds a matrix with give number of r rows and c columns. The elements of the matrix are obtained evaluating f(row, colums) for each element.
Examples: 
matrixMaker(3,3,defineLambdaFunction('conditionalIfTrue($r==$c,1,0)')) == matrixDiagonal(1, 1, 1)

Group: matrix
Name: matrixSizeColumn
Type: prefix function
Number of args: at least 1
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: matrixSizeColumn [mat] returns the number of columns of the given matrix mat. This function can be also applied to a set of sublist of ({matrix1}, {matrix2}, ..)
Examples: 
matrixSizeColumn((-10_-2, 5_7, -7_-5)#3) == 3

Group: matrix
Name: matrixSizeRow
Type: prefix function
Number of args: at least 1
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: matrixSizeRow [mat] returns the number of rows of given matrix mat. This function can be also applied to a set of sublist of ({matrix1}, {matrix2}, ..)
Examples: 
matrixSizeRow((-10_-2, 5_7, -7_-5)#3) == 1

Group: matrix
Name: matrixSort
Type: prefix function
Number of args: at least 1
Supported domain: ({Interval List of []},Positive Interval and Point Interval and Integer Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: matrixSort ({[matrix]}, SortColumnOrder1, SortColumnOrder2, .., SortColumnOrderN  ) returns a matrix where the rows were sorted in ascendin order the give sequence (SortColumnOrder1, .., SortColumnOrderN).
SortColumnOrder is the column to compare for the sorting. If SortColumnOrder is between 0 ans columnSize-1 it means ascending order. If SortColumnOrder is between columnSize and 2*ColumnSize-1 it means descending order.
Examples: 
matrixSort({[[1,2,3],[3,2,1],[2,1,3],[1,3,2]]},1,2) ==  [[2,1,3],[3,2,1],[1,2,3],[1,3,2]]

Group: matrix
Name: matrixSpreadOnColumns
Type: prefix function
Number of args: at least 2
Supported domain: (Prefix Function with at least 1 arguments,{Interval List of []})
Does not extend to list
This function is locked: cannot be changed by user
Help: matrixSpreadOnColumns ($func, {[mat]}) applies the given prefix function func to the following matrix mat column by column.
For example matrixSpreadOnColumns ($average,{2, 3, 4, 5}, 2) = (average(2,3), average(4,5)). It is also possible to apply to a list of matrices { matrix1 }, { matrix2 }, .. 
Examples: 
matrixSpreadOnColumns($statisticAverage, {(2 .. 7)#2}) == 4, 5
matrixSpreadOnColumns($statisticAverage, {(2 .. 7)#3}) == 3.5, 4.5, 5.5
$a = (1 .. 9)#3;matrixSpreadOnColumns($statisticAverage,{a}) == 4,5,6

Group: matrix
Name: matrixSpreadOnRows
Type: prefix function
Number of args: at least 2
Supported domain: (Prefix Function with at least 1 arguments,{Interval List of []})
Does not extend to list
This function is locked: cannot be changed by user
Help: matrixSpreadOnRows ($func, {[mat]}) applies the given prefix function func to the following matrix mat row by row.
For example matrixSpreadOnRows ($average,{2, 3, 4, 5}, 2) = (average(2,3), average(4,5)). It is also possible to apply to a list of matrices { matrix1 }, { matrix2 }, .. 
Examples: 
matrixSpreadOnRows($statisticAverage, {(2 .. 7)#2}) == 2.5, 4.5, 6.5
matrixSpreadOnRows($statisticAverage, {(2 .. 7)#3}) == 3, 6
$a = (1 .. 9)#3;matrixSpreadOnRows($statisticAverage,{a}) == 2,5,8

Group: matrix
Name: matrixTranspose
Type: prefix function
Number of args: at least 4
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: matrixTranspose [mat] transposes the matrix mat.
It means every element a(i,j) is exchanged with a(j,i). This function can be also applied to a set of sublist of ({matrix1}, {matrix2}, ..)
Examples: 
matrixTranspose((1, 2, 3, 4)#2) == (1, 3, 2, 4)#2

Group: measurementUnit
Name: (A/m)
Definition: A/m
Type: Measurement Unit
Synonyms:
 Description: magnetic field strength
  Symbol: (A/m)
Base value: m-1 A1 

Group: measurementUnit
Name: (C/kg)
Definition: C/kg
Type: Measurement Unit
Synonyms:
 Description: exposure (X and gamma rays)
  Symbol: (C/kg)
Base value: kg-1 s1 A1 

Group: measurementUnit
Name: (F/m)
Definition: F/m
Type: Measurement Unit
Synonyms:
 Description: permittivity
  Symbol: (F/m)
Base value: m-3 kg-1 s4 A2 

Group: measurementUnit
Name: (Gy/s)
Definition: Gy/s
Type: Measurement Unit
Synonyms:
 Description: absorbed dose rate
  Symbol: (Gy/s)
Base value: m2 s-3 

Group: measurementUnit
Name: (H/m)
Definition: H/m
Type: Measurement Unit
Synonyms:
 Description: permeability
  Symbol: (H/m)
Base value: m1 kg1 s-2 A-2 

Group: measurementUnit
Name: (J/K kg)
Definition: J/K kg
Type: Measurement Unit
Synonyms:
 Description: specific entropy
  Symbol: (J/K kg)
Base value: m2 s-2 K-1 

Group: measurementUnit
Name: (J/K mol)
Definition: J/K mol
Type: Measurement Unit
Synonyms:
 Description: molar heat capacity
  Symbol: (J/K mol)
Base value: m2 kg1 s-2 K-1 mol-1 

Group: measurementUnit
Name: (J/K)
Definition: J/K
Type: Measurement Unit
Synonyms:
 Description: entropy
  Symbol: (J/K)
Base value: m2 kg1 s-2 K-1 

Group: measurementUnit
Name: (J/mol)
Definition: J/mol
Type: Measurement Unit
Synonyms:
 Description: molar energy
  Symbol: (J/mol)
Base value: m2 kg1 s-2 mol-1 

Group: measurementUnit
Name: (N m s)
Definition: N m s
Type: Measurement Unit
Synonyms:
 Description: angolar momentum
  Symbol: (N m s)
Base value: m2 kg1 s-1 

Group: measurementUnit
Name: (N s)
Definition: N s
Type: Measurement Unit
Synonyms:
 Description: momentum
  Symbol: (N s)
Base value: m1 kg1 s-1 

Group: measurementUnit
Name: (N/m)
Definition: N/m
Type: Measurement Unit
Synonyms:
 Description: surface tension
  Symbol: (N/m)
Base value: kg1 s-2 

Group: measurementUnit
Name: (Pa s)
Definition: Pa s
Type: Measurement Unit
Synonyms:
 Description: dynamic viscosity
  Symbol: (Pa s)
Base value: m-1 kg1 s-1 

Group: measurementUnit
Name: (S m2/mol)
Definition: S m2/mol
Type: Measurement Unit
Synonyms:
 Description: molar conductivity
  Symbol: (S m2/mol)
Base value: kg-1 s3 A2 mol-1 

Group: measurementUnit
Name: (S/m)
Definition: S/m
Type: Measurement Unit
Synonyms:
 Description: conductivity
  Symbol: (S/m)
Base value: m-3 kg-1 s3 A2 

Group: measurementUnit
Name: (V/m)
Definition: V/m
Type: Measurement Unit
Synonyms:
 Description: electric field strength
  Symbol: (V/m)
Base value: m1 kg1 s-3 A-1 

Group: measurementUnit
Name: (W/m K)
Definition: W/m K
Type: Measurement Unit
Synonyms:
 Description: thermal conductivity
  Symbol: (W/m K)
Base value: m1 kg1 s-3 K-1 

Group: measurementUnit
Name: (W/m2)
Definition: W/m2
Type: Measurement Unit
Synonyms:
 Description: heat flux density
  Symbol: (W/m2)
Base value: kg1 s-3 

Group: measurementUnit
Name: (kg/m3)
Definition: kg/m3
Type: Measurement Unit
Synonyms:
 Description: density
  Symbol: (kg/m3)
Base value: m-3 kg1 

Group: measurementUnit
Name: (m/s)
Definition: m/s
Type: Measurement Unit
Synonyms:
 Description: speed
  Symbol: (m/s)
Base value: m1 s-1 

Group: measurementUnit
Name: (m/s2)
Definition: m/s2
Type: Measurement Unit
Synonyms:
 Description: acceleration
  Symbol: (m/s2)
Base value: m1 s-2 

Group: measurementUnit
Name: (m/s3)
Definition: m/s3
Type: Measurement Unit
Synonyms:
 Description: jerk
  Symbol: (m/s3)
Base value: m1 s-3 

Group: measurementUnit
Name: (m2/s)
Definition: m2/s
Type: Measurement Unit
Synonyms:
 Description: kinematik viscosity
  Symbol: (m2/s)
Base value: m2 s-1 

Group: measurementUnit
Name: (m3/mol)
Definition: m3/mol
Type: Measurement Unit
Synonyms:
 Description: molar volume
  Symbol: (m3/mol)
Base value: m3 mol-1 

Group: measurementUnit
Name: (mol/m3)
Definition: mol/m3
Type: Measurement Unit
Synonyms:
 Description: amount of substance concentration
  Symbol: (mol/m3)
Base value: m-3 mol1 

Group: measurementUnit
Name: 1
Definition: System defined by base
Type: Measurement Unit
Synonyms:
 Description: pure
  Symbol: 1
 Description: steradian, solid angle
  Symbol: sr
 Description: radian, angle
  Symbol: rad
Base value: 

Group: measurementUnit
Name: @
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Not Literal)
Supported right domain: (Literal)
Priority: 12, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: (list) @ 'measurementUnit' : given a list of values it set up the measurement units for this list.
The measurement unit has to be set on the single interval. During some calculatio a ICE would stop if the measuremnt units do not match. The measurement unit can be find in the help menu and are literal like 'A' for ampere or 'V' for Volt. However every measurement unit with a valid name creates a variable containing its literal value. Therefore after loading the package the variable V would contain 'V' (if it was not previously used). If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(; 5 @ V / 5 @ A) == (1 @ 'Ohm')

Group: measurementUnit
Name: A
Definition: System defined by base
Type: Measurement Unit
Synonyms:
 Description: ampere, electric current
  Symbol: A
Base value: A1 

Group: measurementUnit
Name: C
Definition: s A
Type: Measurement Unit
Synonyms:
 Description: coulumb, electric charge or quantity of electircity
  Symbol: C
Base value: s1 A1 

Group: measurementUnit
Name: F
Definition: C/V
Type: Measurement Unit
Synonyms:
 Description: farad, electric capacitance
  Symbol: F
Base value: m-2 kg-1 s4 A2 

Group: measurementUnit
Name: Gy
Definition: J/kg
Type: Measurement Unit
Synonyms:
 Description: gray, absorbed dose of ionizing radiation
  Symbol: Gy
Base value: m2 s-2 

Group: measurementUnit
Name: H
Definition: Wb/A
Type: Measurement Unit
Synonyms:
 Description: henry, inductance
  Symbol: H
Base value: m2 kg1 s-2 A-2 

Group: measurementUnit
Name: Hz
Definition: 1/s
Type: Measurement Unit
Synonyms:
 Description: hertz, frequency
  Symbol: Hz
Base value: s-1 

Group: measurementUnit
Name: J
Definition: N m
Type: Measurement Unit
Synonyms:
 Description: jule, energy or work or heat
  Symbol: J
Base value: m2 kg1 s-2 

Group: measurementUnit
Name: K
Definition: System defined by base
Type: Measurement Unit
Synonyms:
 Description: kelvin, temperature
  Symbol: K
Base value: K1 

Group: measurementUnit
Name: N
Definition: kg m / s2
Type: Measurement Unit
Synonyms:
 Description: newton, force and weight
  Symbol: N
Base value: m1 kg1 s-2 

Group: measurementUnit
Name: Ohm
Definition: V/A
Type: Measurement Unit
Synonyms:
 Description: ohm, electric impedance or resistance or reactance
  Symbol: Ohm
Base value: m2 kg1 s-3 A-2 

Group: measurementUnit
Name: Pa
Definition: N/m2
Type: Measurement Unit
Synonyms:
 Description: pascal, pressure stress
  Symbol: Pa
Base value: m-1 kg1 s-2 

Group: measurementUnit
Name: S
Definition: A/V
Type: Measurement Unit
Synonyms:
 Description: siemens, electric conductance
  Symbol: S
Base value: m-2 kg-1 s3 A2 

Group: measurementUnit
Name: T
Definition: Wb/m2
Type: Measurement Unit
Synonyms:
 Description: tesla, magnetic flux strength
  Symbol: T
Base value: kg1 s-2 A-1 

Group: measurementUnit
Name: V
Definition: W/A
Type: Measurement Unit
Synonyms:
 Description: volt, voltage or electromotive force
  Symbol: V
Base value: m2 kg1 s-3 A-1 

Group: measurementUnit
Name: W
Definition: J/s
Type: Measurement Unit
Synonyms:
 Description: watt, power or radiant flux
  Symbol: W
Base value: m2 kg1 s-3 

Group: measurementUnit
Name: Wb
Definition: V s
Type: Measurement Unit
Synonyms:
 Description: weber, magnetic flux
  Symbol: Wb
Base value: m2 kg1 s-2 A-1 

Group: measurementUnit
Name: cd
Definition: System defined by base
Type: Measurement Unit
Synonyms:
 Description: candela, luminescent intensity
  Symbol: cd
Base value: cd1 

Group: measurementUnit
Name: kat
Definition: mol/s
Type: Measurement Unit
Synonyms:
 Description: katal, catalytic activity
  Symbol: kat
Base value: s-1 mol1 

Group: measurementUnit
Name: kg
Definition: System defined by base
Type: Measurement Unit
Synonyms:
 Description: kilogram, mass
  Symbol: kg
Base value: kg1 

Group: measurementUnit
Name: lx
Definition: cd/m2
Type: Measurement Unit
Synonyms:
 Description: lux, illuminance
  Symbol: lx
Base value: m-2 cd1 

Group: measurementUnit
Name: m
Definition: System defined by base
Type: Measurement Unit
Synonyms:
 Description: metre, length
  Symbol: m
Base value: m1 

Group: measurementUnit
Name: measurementUnitDefine
Type: prefix function
Number of args: 3
Supported domain: (Literal,Literal,Literal)
Automatically extends to list
This function is locked: cannot be changed by user
Help: measurementUnitDefine (symbolName, description, definition) create a new measurement unit with given symbolName for definition.
The symbolName can be the void literal '' if the new unit does not have a name like the speed m/s. The description is used for help and is optional. The definition requires any combination of previous defined units and exponent (positive or negative). It also possible to use the division symbol / : all the terms after division have the exponent negated. It is possible to use brackets. The space stands for times and it is required to separate the different units. A measurement unit can be defined several times as far as they have different symbols like rad, srad and pure have the same meaning. When ICE has to print an unit with multiple synonims it will use the last used as input or defined (if it is never used as input).
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
measurementUnitDefine ('speed', 'the velocity', 'm/s'); 6 @'m' / 3 @'s' == 2 @ 'speed'

Group: measurementUnit
Name: measurementUnitManage
Type: prefix function
Number of args: 1
Supported domain: (Logic Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: measurementUnitManage [true|false] : define if ICE has to manage the measurement units.
By default ICE does not manage measurement unit although they are set. However when the meaurement unit group is loaded this seting is changed to true but it is still possible disable the check with measurementUnitManage .

Group: measurementUnit
Name: mol
Definition: System defined by base
Type: Measurement Unit
Synonyms:
 Description: mole, amount of substance
  Symbol: mol
Base value: mol1 

Group: measurementUnit
Name: s
Definition: System defined by base
Type: Measurement Unit
Synonyms:
 Description: second, time
  Symbol: s
Base value: s1 

Group: multilineExpression
Name: multilineExpressionGetResult
Type: prefix function
Number of args: 1
Supported domain: (Point Interval and Integer Interval and Positive Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: multilineExpressionGetResult index retriever the previous computed lines results.
index = 0 is the last line result and so on. The maximum number of saved results is 5
Examples: 
multilineExpressionStatement
a=0
i=1
'loop';
i = i * 2
a = a + 1
conditionalIfTrue(multilineExpressionGetResult 0 < 50, multilineExpressionGoTo 'loop', multilineExpressionGetResult 1)
multilineExpressionStatement
 == 2 ^ 50

Group: multilineExpression
Name: multilineExpressionGoSub
Type: prefix function
Number of args: 1
Supported domain: (Literal)
Does not extend to list
This function is locked: cannot be changed by user
Help: multilineExpressionGoSub it is like go to a 'label'. However the next line continues after a return.
It is used to change the work flow calling sub  multi expression in multiline expression. The label is defined with the label name within apices followed by ; The maximum gosub depth is 100. Those instructions can be placed where ever in the current line. They are evaluated at the execution of the current line so a goto at the beginning would not skip the following calculation in the same line. It is possible just place one (1) multilineExpression or sub Expression flow control instruction per code line. 
Examples: 
multilineExpressionStatement
a=1,i=0
'loop';
multilineExpressionGoSub 'calc'
i=i+1
conditionalIfTrue(i < 50, multilineExpressionGoToBeforePrevious, 1)
multilineExpressionGoToEnd a
'calc';
a = a * 2
multilineExpressionReturn 
multilineExpressionStatement == 2 ^ 50

Group: multilineExpression
Name: multilineExpressionGoTo
Type: prefix function
Number of args: 1
Supported domain: (Literal)
Does not extend to list
This function is locked: cannot be changed by user
Help: multilineExpressionGoTo 'label' go to the given label.
It is used to change the work flow in multiline expression. The label is defined with the label name within apices followed by ;Those instructions can be placed where ever in the current line. They are evaluated at the execution of the current line so a goto at the beginning would not skip the following calculation in the same line. It is possible just place one (1) multilineExpression or sub Expression flow control instruction per code line. 
Examples: 
multilineExpressionStatement
a=0
i=1
'loop';
a = a + 1
i = i * 2
conditionalIfTrue(a < 50, multilineExpressionGoTo 'loop',i)
multilineExpressionStatement
 == 2 ^ 50

Group: multilineExpression
Name: multilineExpressionGoToAfterNext
Type: variable
This variable is locked: cannot be changed by user
Help: multilineExpressionGoToAfterNext go to after the next expression line.
Those instructions can be placed where ever in the current line. They are evaluated at the execution of the current line so a goto at the beginning would not skip the following calculation in the same line. It is possible just place one (1) multilineExpression or sub Expression flow control instruction per code line. 
Examples: 
multilineExpressionStatement
a=1,i=0
'loop';
a = a *2, i=i+1
conditionalIfTrue(i < 50, 1, multilineExpressionGoToAfterNext)
multilineExpressionGoTo 'loop'
a
multilineExpressionStatement == 2^50

Group: multilineExpression
Name: multilineExpressionGoToBeforePrevious
Type: variable
This variable is locked: cannot be changed by user
Help: multilineExpressionGoToBeforePrevious go to the expression line before the previous.
Those instructions can be placed where ever in the current line. They are evaluated at the execution of the current line so a goto at the beginning would not skip the following calculation in the same line. It is possible just place one (1) multilineExpression or sub Expression flow control instruction per code line. 
Examples: 
multilineExpressionGoToBeforePrevious(multilineExpressionStatement
a=1,i=0
a = a *2
i=i+1
conditionalIfTrue(i < 50, multilineExpressionGoToBeforePrevious,a)
multilineExpressionStatement) == 2 ^ 50

Group: multilineExpression
Name: multilineExpressionGoToBegin
Type: variable
This variable is locked: cannot be changed by user
Help: multilineExpressionGoToBegin go to the begin: at the expression line after the initial multilineExpressionStatement.
Those instructions can be placed where ever in the current line. They are evaluated at the execution of the current line so a goto at the beginning would not skip the following calculation in the same line. It is possible just place one (1) multilineExpression or sub Expression flow control instruction per code line. 
Examples: 
multilineExpressionGoToBegin(multilineExpressionStatement
a=statisticRandom(1_100)
conditionalIfTrue(a < 50, multilineExpressionGoToBegin, a >= 50)
multilineExpressionStatement) == true

Group: multilineExpression
Name: multilineExpressionGoToEnd
Type: prefix function
Number of args: 1
Supported domain: (Not Literal)
Does not extend to list
This function is locked: cannot be changed by user
Help: multilineExpressionGoToEnd value go to the end of the current multiple line expression and returns value.
It is used to complete the execution if after there are lines that do not have to be executed because called by goto or gosub.
Examples: 
multilineExpressionStatement
a=0
i=1
'loop';
a = a + 1
i = i * 2
conditionalIfTrue(a < 50, 0, multilineExpressionGoToEnd i)
multilineExpressionGoTo 'loop'
multilineExpressionStatement
 == 2 ^ 50

Group: multilineExpression
Name: multilineExpressionGoToPrevious
Type: variable
This variable is locked: cannot be changed by user
Help: multilineExpressionGoToPrevious go to the previous expression line.
Those instructions can be placed where ever in the current line. They are evaluated at the execution of the current line so a goto at the beginning would not skip the following calculation in the same line. It is possible just place one (1) multilineExpression or sub Expression flow control instruction per code line. 
Examples: 
multilineExpressionGoToPrevious(multilineExpressionStatement
a=1,i=0
a = a *2, i=i+1
conditionalIfTrue(i < 50, multilineExpressionGoToPrevious,a)
multilineExpressionStatement) == 2 ^ 50

Group: multilineExpression
Name: multilineExpressionGoToThis
Type: variable
This variable is locked: cannot be changed by user
Help: multilineExpressionGoToThis go to this expression line.
 Therefore it repeats it again.Those instructions can be placed where ever in the current line. They are evaluated at the execution of the current line so a goto at the beginning would not skip the following calculation in the same line. It is possible just place one (1) multilineExpression or sub Expression flow control instruction per code line. 
Examples: 
multilineExpressionGoToThis(multilineExpressionStatement
a=1,i=0
a = a *2, i=i+1, conditionalIfTrue(i < 50, multilineExpressionGoToThis,a)
multilineExpressionStatement) == 2 ^ 50, 50, 2 ^ 50

Group: multilineExpression
Name: multilineExpressionReturn
Type: variable
This variable is locked: cannot be changed by user
Help: multilineExpressionReturn go to the expression line before the previous.
Those instructions can be placed where ever in the current line. They are evaluated at the execution of the current line so a goto at the beginning would not skip the following calculation in the same line. It is possible just place one (1) multilineExpression or sub Expression flow control instruction per code line. Those instructions can be placed where ever in the current line. They are evaluated at the execution of the current line so a goto at the beginning would not skip the following calculation in the same line. It is possible just place one (1) multilineExpression or sub Expression flow control instruction per code line. 
Examples: 
multilineExpressionStatement
a=1,i=0
'loop';
multilineExpressionGoSub 'calc'
i=i+1
conditionalIfTrue(i < 50, multilineExpressionGoToBeforePrevious, 1)
multilineExpressionGoToEnd a
'calc';
a = a * 2
multilineExpressionReturn 
multilineExpressionStatement == 2 ^ 50

Group: multilineExpression
Name: multilineExpressionStatement
Type: variable
This variable is locked: cannot be changed by user
Help: multilineExpressionStatement is used to define the begin and the end of a multi line expression.
Each expression can be terminated by a new line. All the expressions instructions within multilineExpressionStatement and multilineExpressionStatement are treated as one. The result of the multiline expression is the value of the last one.Those instructions can be placed where ever in the current line. They are evaluated at the execution of the current line so a goto at the beginning would not skip the following calculation in the same line. It is possible just place one (1) multilineExpression or sub Expression flow control instruction per code line. 

Group: optimization
Name: optimizationUnconditionalMinimum
Type: prefix function
Number of args: at least 2
Supported domain: (Prefix Function with at least 1 arguments,Point Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: optimizationUnconditionalMinimum ($func, x0, x1, .., xn) finds the list of input values (x'0, x'1, .., x'n) required to minimize the given error fuction func beginning the search at (x0, x1, .., xn).
It requires the function to be minimized and the initial point values. It is very usefull in design where the function measure how far is from the best result. The starting point must be a list of point intervals and the average value of the function output is used if it is a tick function. The non linear optimizator is downloaded from http://www1.fpl.fs.fed.us/optimization.src.tar.html and it is based on the public domain UNCMIN routines traslated in Java by Steve Verrill.
Examples: 
optimizationUnconditionalMinimum($sin, 3) == 3*PI/2
optimizationUnconditionalMinimum((($f,x,y,z)='(x-2)^2+(y-7)^2+(z-10)^2',0,0,0)) == 2,7,10

Group: plot
Name: plotBodeModule
Type: prefix function
Number of args: 3
Supported domain: (Prefix Function with 1 arguments,Point Interval,Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: plotBodeModule ($f, n, i) computes plotStandardLogarithmic(defineLambdaFunction('20 log (abs ( f ($x) ) )'), n, i) returning the plottable matrix.
This is a system defined function as per the folowing ICE expression: plotStandardLogarithmic( defineLambdaFunction( literalCharJoin('20*log(abs(',f,' $x ))' ) ), n, i)
Examples: 
plotBodeModule($sin, 5, 1_1k) == plotStandardLogarithmic(defineLambdaFunction('20*log(abs( sin $x))'),5, 1_1k)

Group: plot
Name: plotBodePhase
Type: prefix function
Number of args: 3
Supported domain: (Prefix Function with 1 arguments,Point Interval,Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: plotBodePhase ($f, n, i) computes plotStandardLogarithmic(defineLambdaFunction('complexArg (f ($x) ) '), n, i) returning the plottable matrix.
This is a system defined function as per the folowing ICE expression: plotStandardLogarithmic( defineLambdaFunction( literalCharJoin('complexArg(', f, ' $x )/convertDegreeToRadiant ' ) ), n, i)
Examples: 
plotBodePhase($sin, 5, 1_1k) == plotStandardLogarithmic(defineLambdaFunction('complexArg( sin $x)/convertDegreeToRadiant'),5, 1_1k)

Group: plot
Name: plotData
Type: prefix function
Number of args: at least 1
Supported domain: (Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: plotData (list) return the plottable matrix composed by the given list of data in Y axes, for X axes it uses a 0, 1, 2, .. .
It is a function to use when it is required to display some data (Y) and the X is not defined, like the result of a fft or same statistical data. It build a printable matrix to be displayed in plot windows. As X it is use integer number from 0 to size of the input list - 1.
Examples: 
plotData(5,25,255,325) == (0,1,2,3)#1 , (5,25,255,325)#1

Group: plot
Name: plotFunctionPointsByMouseClick
Type: variable
This variable can be changed by user
Help: plotFunctionPointsByMouseClick is automatically filled with points of the mouse pointer clicking with left button on a graph while shift key is pressed.
The right button would delete last added point and the central button the first point.

Group: plot
Name: plotParametric
Type: prefix function
Number of args: 3
Supported domain: (Prefix Function with 1 arguments,Point Interval,Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: plotParametric ($func, nOfPoints, xInterval) computes func (which should provide a list of 2 elements: x and y) for nOfPoints in the given interval returning the plottable matrix.
It builds an array which can later be used to plot the function on the plot display window. It requires a function returning a list of a couple of elements to compute x and y, the number of points, the interval range, the absolute and the relative tolerance of those intervals used to compute the parametric variable.
Examples: 
plotParametric(($f,$x)='(cos x, sin x)', 5, 0_2*PI) == ((1,0,-1,0,1)#1 , (0,1,0,-1,0)#1)

Group: plot
Name: plotParametricTick
Type: prefix function
Number of args: 3
Supported domain: (Prefix Function with 1 arguments,Point Interval,Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: plotParametricTick ($func, nOfIntervals, xInterval) computes func (which should provide a list of 2 elements: x and y) for nOfIntervals in the given interval returning the plottable matrix.
builds an array which can later be used to plot the function on the plot display window. It requires a function returning a list of a couple of elements to compute x and y, the number of intervals and, the interval range used to compute the parametric variable. Those intervals are computed to fill totally the required range without overlapping.
Examples: 
plotParametricTick(($f,$x)='(cos x, sin x)', 2, 0_PI) == ((0_1,-1_0)#1, (-1_1,-1_1)#1)

Group: plot
Name: plotStandard
Type: prefix function
Number of args: 3
Supported domain: (Prefix Function with 1 arguments,Point Interval,Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: plotStandard ($func, nOfPoints, xInterval) computes func (which provides the y value) for nOfPoints in the given interval returning the plottable matrix.
It builds an array which can later be used to plot the function graph. It requires the function name to compute the y, the number of points where it will be evaluated and an interval with the range of the point to be evaluated.
Examples: 
plotStandard($sin, 5, 0_2*PI) == ((0,PI/2,PI,3*PI/2,2*PI)#1 , (0,1,0,-1,0)#1)

Group: plot
Name: plotStandardAdaptive
Parameter: maxDeep
Value: 12
Expected Input: Requires integer value between 1 and 20
Default: 12
Help: The maximum deep (2^maxDeep) to explore for functin characteristics.

Group: plot
Name: plotStandardAdaptive
Parameter: minDeep
Value: 3
Expected Input: Requires integer value between 1 and 10
Default: 3
Help: The minimum deep (2^minDeep) to explore for functin characteristics.

Group: plot
Name: plotStandardAdaptive
Parameter: tolerance
Value: 0.002
Expected Input: Requires double value between 0.0 and 1.0
Default: 0.002
Help: The maximum allowed tolerance in the trapezoid, unless maxDeep is reached.

Group: plot
Name: plotStandardAdaptive
Type: prefix function
Number of args: 2
Supported domain: (Prefix Function with 1 arguments,Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: plotStandardAdaptive ($func, xInterval) computes func (which provides the y value) for the minimum numbero of point to get a good representatin in the given interval returning the plottable matrix.
 plotStandardAdaptive ('f', begin_end) calculate the matrix [x # 1, f(x) #1] to be plot later. The point at which f is calculate are self determinated looking into f variations. The interval is split in sub intervals. The sub intervals are defined in order to get the function values at the interval extremes equal with respect to the function value at the middle. In the ranges where the function is closer to a line less intervals are used. A minimum of 2^4+1 points are used to detect where the function requires more. It is usually faster and more accureta than plotStandard with 100 intervals. For example plotting sin between 0_2PI just takes 65 points. it possible to provide the some setting to the function with the function systemSetupParameters ($plotStandardAdaptive, mindeep, maxdeep, tol): 2^mindeep is the minimum number of interval to set (default is 2^3=8 intervals) the smaller the faster works for simple function however with a too smal set of itnervals a functin may seem stable while it is not. 2^maxdeep is the maximum number of itnervals (default is 2^12=4048), the higher the higher is the accuracy however the computational and memory time will rise exponentially. accuracy is how the trapezoid found looks good to calculate its area. A smaller value will require more intervals as far as 2^maxdeep is reached.
Examples: 
plotStandardAdaptive(defineLambdaFunction('2*$x+5'),0_10) == listLinear(2^4+1, 0_10) # 1 , defineLambdaFunction('2*$x+5', listLinear(2^4+1, 0_10)) # 1

Group: plot
Name: plotStandardLogarithmic
Type: prefix function
Number of args: 3
Supported domain: (Prefix Function with 1 arguments,Point Interval,Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: plotStandardLogarithmic ($func, nOfPoints, xInterval) computes func (which provides the y value) for nOfPoints logarithmically spaced in the given interval returning the plottable matrix.
It builds an array which can later be used to plot the function graph. It requires the function name to compute the y, the number of points where it will be evaluated and an interval with the range of the point to be evaluated. The x will be logarithmically spaced. This function is useful to have the function points equally spaced for logarithmic plot.
Examples: 
plotStandardLogarithmic(defineLambdaFunction('$x'), 5, 1_1k) == (listLogarithmic (5, 1_1k) # 1, defineLambdaFunction('$x',listLogarithmic (5, 1_1k)) # 1)

Group: plot
Name: plotStandardTick
Type: prefix function
Number of args: 3
Supported domain: (Prefix Function with 1 arguments,Point Interval,Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: plotStandardTick ($func, nOfIntervals, xInterval) computes func (which should provide y values) for nOfIntervals in the given interval returning the plottable matrix.
It build an array which can later be used to plot the function graph. It requires the function name to compute the y, the number of intervals where it will be evaluated and an interval with the range of the intervals to be evaluated. Those intervals are automatically computed to fill in all the required interval without overlapping.
Examples: 
plotStandardTick($cos, 2, 0_PI) == (((-PI/2)_(PI/2),(PI/2)_(3*PI/2))#1 , (0_1,-1_0)#1)

Group: plot
Name: plotSurface
Type: prefix function
Number of args: 5
Supported domain: (Prefix Function with 2 arguments,Point Interval,Real Interval,Point Interval,Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: plotSurface ($func, nXint, X_range, nYint, Y_range) returns a 3 column plottable matrix where func (of two arguments x and y) is computed at every x, y square made by splitting X and Y ranges in nXint and nYint intervals.
It builds an array which can later be used to plot the height of a function with a color graph. It requires the function name to compute its height (z), the number of squares on x, the range of x, the number of square on y, the range of y.
Examples: 
sp=plotSurface(($f,x,y)='x+y', 2, 2_4, 2, 2_4);sp == ((1_3,1_3,3_5,3_5)#1 , (1_3,3_5,1_3,3_5)#1 , (2_6,4_8,4_8,6_10)#1)

Group: plot
Name: plotVector
Type: prefix function
Number of args: 5
Supported domain: (Prefix Function with 2 arguments,Point Interval,Real Interval,Point Interval,Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: plotVector ($func, nXint, X_range, nYint, Y_range) returns a 4 column plottable matrix where func (of two arguments x and y and returning a list of 2 values xVector, yVector) is computed at every x, y point made by splitting X and Y ranges in nXint and nYint intervals.
It builds an array which can later be used to plot the vector field given by the input fuction. It requires the function name to compute its vector field (return fields components x,y), the number of points on x, the range of x, the number of points on y, the range of y.
Examples: 
plotVector(defineLambdaFunction('-$y,$x'), 2, 2_4, 2, 2_4) == (2,2,-2,2,2,4,-4,2,4,2,-2,4,4,4,-4,4)#4

Group: polynomial
Name: *****
Type: infix function
Number of left args:  variable
Number of right args:  at least 1
Supported left domain: (Complex Interval)
Supported right domain: (Complex Interval)
Priority: 10, Min Priority: 0, Max Priority: 13
Associativity: left to right
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: (poly1) ***** (poly2) returns the polynomial given by the multiplication of poly1 and 2.
poly1 and poly2 should contain the coefficients of the two polynomial ordered from the higher to lower grades. The result is the coefficient of the polynomial ordered from highest to lower grade.
Examples: 
(1,2)*****(1,4) == (1, 6, 8)

Group: polynomial
Name: +++++
Type: infix function
Number of left args:  variable
Number of right args:  at least 1
Supported left domain: (Complex Interval)
Supported right domain: (Complex Interval)
Priority: 9, Min Priority: 0, Max Priority: 13
Associativity: left to right
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: (poly1) +++++ (poly2) returns the polynomial given by the sum of the two polynomials.
poly1 and poly2 should contain the coefficients of the two polynomial ordered from the higher to lower grades.
Examples: 
(1,2)+++++(1,4) == (2, 6)
(1)+++++(3,4,1) == (3,4,2)
(3,4,1)+++++(1) == (3,4,2)

Group: polynomial
Name: -----
Type: infix function
Number of left args:  variable
Number of right args:  at least 1
Supported left domain: (Complex Interval)
Supported right domain: (Complex Interval)
Priority: 9, Min Priority: 0, Max Priority: 13
Associativity: left to right
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: (poly1) ----- (poly2) returns the polynomial given by the difference of the two polynomials.
poly1 and poly2 should contain the coefficients of the two polynomial ordered from the higher to lower grades.
Examples: 
(1,2)-----(1,4) == (-2)
(1)-----(3,4,1) == (-3,-4,0)
(3,4,1)-----(1) == (3,4,0)

Group: polynomial
Name: /////
Type: infix function
Number of left args:  variable
Number of right args:  at least 1
Supported left domain: (Complex Interval)
Supported right domain: (Complex Interval)
Priority: 10, Min Priority: 0, Max Priority: 13
Associativity: left to right
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: (poly1) ///// (poly2) returns the polynomials the coefficients of the quotient of the division between poly1 and poly2 and its reminder.
The result is provided in two sub-lists ({q},{r}), where q contains quotient and r the remider. The coefficients of the two polynomials are ordered from the higher to lower grades.
Examples: 
((1,2) ***** (1,4))/////(1,4) == ({1, 2},{0})

Group: polynomial
Name: polynomialDerivate
Type: prefix function
Number of args: at least 1
Supported domain: (Complex Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: polynomialDerivate (an, an-1, .., a1, a0) returns the polynomial given by the first derivate of the given one.
Examples: 
polynomialDerivate(polynomialIntegrate(1,5,6)) == 1,5,6

Group: polynomial
Name: polynomialEvaluate
Type: prefix function
Number of args: at least 2
Supported domain: ({Interval List of []},Complex Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: polynomialEvaluate ({an, an-1, .., a1, a0}, eval1, eval2, .., evaln) evaluate the polynomial in variable x with given coefficients at the given points eva1, .., evaln.
The polynomial coefficents are from the maximum grade x (x^n) to the minimum (x^0). 
Examples: 
polynomialEvaluate({1,2,3},1,2) ==  defineLambdaFunction ('$x^2+2*$x+3',1,2)

Group: polynomial
Name: polynomialIntegrate
Type: prefix function
Number of args: at least 1
Supported domain: (Complex Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: polynomialIntegrate (an, an-1, .., a1, a0) returns the polynomial given by the integration of the given one.
The constant coefficient is set to 0.
Examples: 
polynomialIntegrate(polynomialDerivate(1,2,3,4)) == 1,2,3,0

Group: polynomial
Name: polynomialSolve
Parameter: epsilon
Value: 1.0E-6
Expected Input: Requires double value between 0.0 and 1.0
Default: 1.0E-6
Help: The maximum distance between the f(x) and zero, below the iterations stops

Group: polynomial
Name: polynomialSolve
Parameter: maxIteration
Value: 100
Expected Input: Requires integer value between 1 and 1000
Default: 100
Help: The maximum number of iterations, above which it stops

Group: polynomial
Name: polynomialSolveDK
Parameter: epsilon
Value: 1.0E-6
Expected Input: Requires double value between 0.0 and 1.0
Default: 1.0E-6
Help: The maximum distance between two iterations, below this value it stops

Group: polynomial
Name: polynomialSolveDK
Parameter: maxIteration
Value: 100
Expected Input: Requires integer value between 1 and 1000
Default: 100
Help: The maximum number of iterations, above which it stops

Group: polynomial
Name: polynomialSolveDK
Type: prefix function
Number of args: 2
Supported domain: ({Interval List of []},{Interval List of []})
Does not extend to list
This function is locked: cannot be changed by user
Help: polynomialSolveDK ({an, an-1, .., a1, a0}, {rn-1, rn-2, .., r1, r0}) given the coefficients of polynomial and a first guess of the roots it tries to find iterativaly all the available roots at the same time.
The algorithm is based on Durand–Kerner method described on https://en.wikipedia.org/wiki/Durand%E2%80%93Kerner_method. To find complex roots the starting point should be complex number and they should be inside some not-too-large circle containing also the roots of ƒ(x) and they should not be close to each other: do not use the same starting points for two roots.
Examples: 
polynomialSolveDK({1,5,6},{-1,-4}) == -2,-3
polynomialSolveDK({(1, -6) ***** (1, -3)}, {1,10}) == 3, 6

Group: polynomial
Name: polynomialSolveJT
Type: prefix function
Number of args: at least 2
Supported domain: (Point Interval Not Complex)
Does not extend to list
This function is locked: cannot be changed by user
Help: polynomialSolveJT (an, an-1, .., a1, a0) given the coefficients of polynomial it tries to find iterativaly all the available roots at the same time.
The algorithm is the one written by Jenkins Traub. This is a Java port of Fortran source code by Michael A. Jenkins. Copyright notice for the Java port: Copyright 2013 Christian d'Heureuse, Inventec Informatik AG, Zurich, Switzerland. The source code are available on  http://svn.source-code.biz/dsp-java/trunk/src/main/java/biz/source_code/dsp/math/PolynomialRootFinderJenkinsTraub.java  and http://svn.source-code.biz/dsp-java/trunk/src/main/java/biz/source_code/dsp/math/Complex.java  
Examples: 
polynomialSolveJT(1,5,6) == -2,-3
polynomialSolveJT((1, -6) ***** (1, -3)) == 3, 6

Group: polynomial
Name: polynomialSolveL
Type: prefix function
Number of args: 2
Supported domain: ({Interval List of []},{Interval List of []})
Does not extend to list
This function is locked: cannot be changed by user
Help: polynomialSolveL ({an, an-1, .., a1, a0}, {rn-1, rn-2, .., r1, r0}) given the coefficients of polynomial and a first guess of the roots it finds iterativaly all the available roots.
The algorithm is based on Laguerre's method: https://en.wikipedia.org/wiki/Laguerre%27s_method .To find complex roots for each starting point the algorithm of Laguerre is applied.The algorithm try to find a zero after the other in the order given in input. Once a zero is found, the original polynomium is deflated dividing by the root just found. For numerical stability it is better starting from smaller roots.
Examples: 
polynomialSolveL({1,5,6},{1,2}) == -2,-3
polynomialSolveL({(1, -6) ***** (1, -3)}, {1,10}) == 3, 6

Group: polynomial
Name: polynomialSolveNR
Type: prefix function
Number of args: 2
Supported domain: ({Interval List of []},{Interval List of []})
Does not extend to list
This function is locked: cannot be changed by user
Help: polynomialSolveNR ({an, an-1, .., a1, a0}, {rn-1, rn-2, .., r1, r0}) given the coefficients of polynomial and a first guess of the roots it finds iterativaly all the available roots.
The algorithm is based on Newton-Raphson algorithm: https://en.wikipedia.org/wiki/Newton%27s_method .To find complex roots for each starting point the algorithm of Newton Rapshon is applied.The algorithm try to find a zero after the other in the order given in input. Once a zero is found, the original polynomium is deflated dividing by the root just found. For numerical stability it is better starting from smaller roots.
Examples: 
polynomialSolveNR({1,5,6},{-1,-4}) == -2,-3
polynomialSolveNR({(1, -6) ***** (1, -3)}, {1,10}) == 3, 6

Group: polynomial
Name: polynomialTaylor
Type: prefix function
Number of args: at least 2
Supported domain: (Complex Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: polynomialTaylor (x0, f(x0), f'(x0), f''(x0), ..) returns the Tylor polynomial computed at x0.
Examples: 
;polynomialEvaluate({polynomialTaylor(1, listClone(12, E))}, listLinear(5, 0_2)) == exp listLinear(5, 0_2)

Group: power
Name: E
Type: variable
This variable is locked: cannot be changed by user
Help: This is the Neper number: 2.78.
It is given by the following limit: x->infinity (1+1/x)^x

Group: power
Name: ^
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Real Interval)
Supported right domain: (Real Interval)
Priority: 11, Min Priority: 0, Max Priority: 13
Associativity: right to left
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: a ^ b rises a to the power of b. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(-1_2)^(2) == (0_4)
(-1_2)^(3) == (-1_8)
(1_2)^(2) == (1_4)
(1_2)^(3) == (1_8)

Group: power
Name: exp
Type: prefix function
Number of args: 1
Supported domain: (Complex Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: exp (a) computes E ^ a (where E is Neper number) in a more computational efficient way.
Moreover exp supports complex number.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
exp(-1_2) == E^(-1_2)
exp(-1_2) == E^(-1_2)
exp(1_2) == E^(1_2)
exp(1_2) == E^(1_2)
exp(21_2) == E^(21_2)
exp(21_2) == E^(21_2)
exp(1 +| (PI/2)) == I * E

Group: power
Name: sqr
Type: prefix function
Number of args: 1
Supported domain: (Complex Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: sqr (a) computes the square the interval a.
It is extended to directed intervals but needs to be verified in that case. It works on complex point intervals.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
sqr(-10_2, -10_-2, 5_7, -7_-5) == 0_100, 4_100, 25_49, 25_49

Group: power
Name: sqrt
Type: prefix function
Number of args: 1
Supported domain: (Complex Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: sqrt (a) computes the positive square root the interval a.
It is required interval a should not contain negative values. It functionality is extended to directed intervals. It works on complex point intervals.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
sqrt(0_100, 25_49) == 0_10,5_7

Group: program
Name: programArgumentSize
Type: prefix function
Number of args: 1
Supported domain: (Literal)
Automatically extends to list
This function is locked: cannot be changed by user
Help: programArgumentSize ($func) returns the number of argument required of the given prefix function func.
It can be used to check if a function argument is correct within a functions. It returns 0 for variables and all other stuff.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
programArgumentSize($sin) == 1
programArgumentSize($cos) == 1
programArgumentSize($plotStandard) == 3

Group: program
Name: programCallFunction
Type: prefix function
Number of args: at least 1
Supported domain: (Prefix Function with at least 1 arguments,Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: programCallFunction ($func, arg1, arg2, .., argn) returns func(arg1, arg2, .., argn).
It requires a literal which is the function name to be called followed by its arguments. It is useful to define new functions that accepts function as arguments.
Examples: 
programCallFunction($cos, 0) == 1

Group: program
Name: programError
Type: prefix function
Number of args: 1
Supported domain: (Literal)
Does not extend to list
This function is locked: cannot be changed by user
Help: programError ('error message') stops the current execution flow generating an error which reports the given 'error message' to the user.
It can be useful for user defined functions to rise exception.
Examples: 
;programOnErrorReturn(defineLambdaFunction 'programError ($x)','error should have been risen','error catched') == 'error catched'

Group: program
Name: programOnErrorReturn
Type: prefix function
Number of args: 3
Supported domain: (Prefix Function with 1 arguments,Interval,Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: programOnErrorReturn ($func, arg, onErrArg) try to compute and return func(arg), if that rises any error it returns onErrArg.
This function can be used to show any error (risen by sub function) to the user.
Examples: 
programOnErrorReturn(defineLambdaFunction 'sin $x / $x',0,1) == 1
programOnErrorReturn(defineLambdaFunction 'sin $x / $x',5,1) == sin 5 / 5

Group: program
Name: programTimeMs
Type: prefix function
Number of args: 0
Supported domain:  everything
Automatically extends to list
This function is locked: cannot be changed by user
Help: programTimeMs () returns the current time in milliseconds.
Note that while the unit of time of the return value is a millisecond, the granularity of the value depends on the underlying operating system and may be large. For example, many operating systems measure time in units of tens of milliseconds. This function may be useful for profiling: to measure the execution time of other functions.
Examples: 
t=programTimeMs();programTimeMs()-t>=0 == 1

Group: program
Name: programType
Type: prefix function
Number of args: 1
Supported domain: (Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: programType (interval) returns a literal showing the type of the given interval.
It can be useful to check the input domain in user function.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
programType(10_10) == 'Point Interval'
programType(10_11) == 'Real Interval'
programType(5+|4) == 'Complex Point Interval'
programType(1_2+|5) == 'Complex Interval'
programType(5+|3_4) == 'Complex Interval'
programType('12') == 'Literal'
programType(5%2+|3-(-5%2+|3)) == 'Real Interval'
programType(5+|3-(-5+|3)) == 'Point Interval'
programType(4_5-intervalDual(4_5)) == 'Point Interval'

Group: reactiveExpression
Name: ===
Type: infix function
Number of left args: 1
Number of right args:  at least 1
Supported left domain: (Literal)
Supported right domain: (Literal)
Priority: 1, Min Priority: 0, Max Priority: 13
Associativity: right to left
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: $variable === ('expression of other already defined variables', [extra dependent variables])  defines a reactive expression.
It is an expression which is automatically called every time any of its argument changes. It is very usefull on the design phase. Usually the best result is not get on the first list of expression. Therefore it is required to compute again the same list of interdependent expressions changing a little some input argument until the optimal result is got. However with reactive expression it is enough to chane any input variable to have them react to recompute their value. The reactive expression can depend on eache other output value. Only the once whose where at least an input is change is recalculated automatically. They are recalculated at the end of the current list of expression unless a manual defineRecurrentExpressionTrigger() is given. It is not allowed any recusive definition (cycle) within a recursive expression (a === 'a + 1') or through them (a === 'b + 1', b === 'a'). The command is used OutputVariableName === ' function of input variables '. If the output variable is deleted the relative reactive expression is deleted as well. In the output variable help is stored the reactive expression syntax. The input argument are automatically extracted by ICE looking at the variables on the right side expression. However ICE may miss some argument if it is written within a literal (defining an expression). For instance in the reactive expression: c === 'a+literalToExpression \'b\'', the bariable b is not recognized because it is written within apices. It is possible to add extra dependences from b with the syntax: $c === ('a+literalToExpression \'b\'', $b) 
Examples: 
($a=1,$b=2;$c==='a+b';$b=1;c==3) == (true)
(reactiveExpressionTrigger(false);c==2) == (true)
(a = 5, b = 7, c === 'a+literalToExpression \'b\''; c == 5+7) == (true)
(a=4,reactiveExpressionTrigger(false);c==4+7) == (true)
(b=4,reactiveExpressionTrigger(false);c==4+7) == (true)
(a = 5, b = 7, c === ('a+literalToExpression \'b\'', $b); c == 5+7) == (true)
(a=4,reactiveExpressionTrigger(false);c==4+7) == (true)
(b=4,reactiveExpressionTrigger(false);c==4+4) == (true)

Group: reactiveExpression
Name: reactiveExpressionDefineFunction
Type: prefix function
Number of args: 3
Supported domain: (Literal,{Interval List of [Function Variable]},Reactive expression)
Does not extend to list
This function is locked: cannot be changed by user
Help: reactiveExpressionDefineFunction ($functionName, {$inputVar1, .., $inputVarn}, $outputReEx) defines a new prefix function which takes n input variables and store them on the system vars: inputVar1, .., inputVarn; then it execute the reactive expressions and return the value of outputReEx.
The purpose of this function it to transform a reactive expression in a standard prefix function which can be used in further calculus like findRoot or optimizer..
Examples: 
$a=5, $y1==='a+5', reactiveExpressionDefineFunction($testfre, {$a}, $y1); a, y1, equationFindRoot($testfre, 0_10, 11), a, y1 == 5, 10, 6, 6, 11

Group: reactiveExpression
Name: reactiveExpressionFindRoot
Type: prefix function
Number of args: 4
Supported domain: (Reactive expression,Function Variable,Real Interval,Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: reactiveExpressionFindRoot ($re, $variable, interval, point) in order to set $re to the same value of point, changes variable in the given interval.
It is the same of equationFindRoot on a function. Consider reactive expressions are slower than functions.
This is a system defined function as per the folowing ICE expression: equationFindRoot(reactiveExpressionDefineFunction(defineLambdaGetName(0) , {in}, out),range,yval)
Examples: 
a1=5,a2==='a1+4';reactiveExpressionFindRoot($a2, $a1, 0_10, 10) == 6 

Group: reactiveExpression
Name: reactiveExpressionOptimizeUnconditionalMinimum
Type: prefix function
Number of args: 2
Supported domain: (Reactive expression,{Interval List of [Function Variable]})
Does not extend to list
This function is locked: cannot be changed by user
Help: reactiveExpressionOptimizeUnconditionalMinimum ($outputReactiveExpression, {$inputVar1, .., $inputVarn}) find the $outputReactiveExpression minimum changing the $inputVar1 to $inputVarn.
At beginning point it takes the current value of inputVar1, .., inputVarn. It is the same of optimizationUnconditionalMinimum executed on a function. Consider reactive expressions are slower than functions.
This is a system defined function as per the folowing ICE expression: optimizationUnconditionalMinimum(reactiveExpressionDefineFunction(defineLambdaGetName (0), in, out), literalToExpression(listFlatten(in)))
Examples: 
aj3 = 5 , aj4 = 11 , $aj5 === 'abs((aj3 - 4)*( aj4 - 10))'; reactiveExpressionOptimizeUnconditionalMinimum($aj5, {$aj3, $aj4}) == 4, 10

Group: reactiveExpression
Name: reactiveExpressionRecursive
Parameter: epsilon
Value: 1.0E-7
Expected Input: Requires double value between 0.0 and 1.0
Default: 1.0E-7
Help: The maximum distance between two iterations, below this value it stops

Group: reactiveExpression
Name: reactiveExpressionRecursive
Parameter: maxIteration
Value: 100
Expected Input: Requires integer value between 1 and 1000
Default: 100
Help: The maximum number of iterations, above which it stops

Group: reactiveExpression
Name: reactiveExpressionRecursive
Type: prefix function
Number of args: at least 3
Supported domain: (Function Variable,Prefix Function with at least 1 arguments,Literal)
Does not extend to list
This function is locked: cannot be changed by user
Help: reactiveExpressionRecursive ($y, $f, $x1, .., $xn) add a recursive equation to the reactive expression set.
ICE computes y=f(x1, .., xn) untile two iteration are within espilon unless max iterations are reached. It is useful if y === 'f(x1, .., xn)' cannot be added because recursive.
Examples: 
vth = 3, vin = 5, rs = 100, id = 0.1m,  k=0.2, vs === 'vin-vth-sqrt (id/k)';reactiveExpressionRecursive($id ,defineLambdaFunction(' $x/rs'), $vs) == vt =vin-vth;equationFindRoot(defineLambdaFunction('$x^2-(1/rs/k+2*vt)*$x+vt^2'),1.6_1.8,0)/rs

Group: reactiveExpression
Name: reactiveExpressionShow
Type: prefix function
Number of args: 0
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: reactiveExpressionShow show all reactive expressions currently stored.
The expressions are showed in the order in which they are computed.

Group: reactiveExpression
Name: reactiveExpressionSummary
Type: prefix function
Number of args: 0
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: reactiveExpressionSummary show the status of all reactive expressions currently stored and their input variables.
The input variables and the expressions are showed in the order in which they are computed.

Group: reactiveExpression
Name: reactiveExpressionTrigger
Type: prefix function
Number of args: 1
Supported domain: (Logic Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: reactiveExpressionTrigger (allReactiveExpression) if allReactiveExpression is false triggers a recalculation of the reactive expression whose input variable were changed, otherwise it computes all of them.
If the input is false only the reactive expression with changed input are recalculated (if any). True is useful to reset the status if some reactiveExpression output was overwritten or to compute a RE depending on external factors (like random or time). A trigger is automatically given at the end of every expression execution.
Examples: 
$are=1,$bre=2;$cre==='are+bre';$bre=1;cre==3 == true
reactiveExpressionTrigger(false);cre==2 == true
$cre==='statisticRandom(0_1)+are',$dre = cre, reactiveExpressionTrigger(false); dre == cre == true
reactiveExpressionTrigger(true); dre != cre == true

Group: setInterval
Name: &
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Real Interval)
Supported right domain: (Real Interval)
Priority: 6, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: intervalsA & intervalsB returns the intersection between the two intervals A and B considered as set of real number.
If the two intervals have no intersection it returns an empty interval. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(6_7)&(4_5) == (6_5)
(5_7)&(4_6) == (5_6)
(1_2)&(2_4) == (2)
(3_4)&(-3_-2) == (3_-2)
('to check if a list of adjacent intervals do not have any intersection the result has to be all -1';a=(1_2,2.1_5,9_10,11_12);intervalDirection(diffuseSpread('&',a))) == (-1,-1,-1)

Group: setInterval
Name: <<
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Real Interval and Proper Interval)
Supported right domain: (Real Interval and Proper Interval)
Priority: 8, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: intervalA << intervalB checks if an intervalA is a subset of intervalB  returning 0 for false, 1 for true.
Subset means every element of the firs interval is available in the second (the opposite is not required). It returns 0 if the preposition is not verified for every point of the first interval, 1 for it is always verified, 0_1 if it is verified only for some points. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(6_7)<<(5_8) == (1)
(6_7)<<(7_8) == (0_1)
(1_2)<<(1.5_3) == (0_1)
(3_4)<<(-3_-2) == (0)

Group: setInterval
Name: >>
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Real Interval and Proper Interval)
Supported right domain: (Real Interval and Proper Interval)
Priority: 8, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: intervalA >> intervalB checks if the intervalA is a super set of the intervalB returning 0 for false, 1 for true.
Super set means every element of the second interval is available in the first (the opposite is not required). It returns 0 if the preposition is not verified for every point of the first interval, 1 for it is always verified, 0_1 if it is verified only for some points. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(6_7)>>(5_8) == (0_1)
(6_9)>>(7_8) == (1)
(1_2)>>(1.5_3) == (0_1)
(3_4)>>(-3_-2) == (0)

Group: setInterval
Name: |
Type: infix function
Number of left args: 1
Number of right args: 1
Supported left domain: (Real Interval)
Supported right domain: (Real Interval)
Priority: 5, Min Priority: 0, Max Priority: 13
Associativity: left to right
Automatically extends scalar input to list
This function is locked: cannot be changed by user
Help: intervalA | intervalB returns the interval which is union of the intervals A and B.
Since the system works only on single interval the joining may contain also points not available in the two intervals if they are disjoint. If the arguments are lists they must have the same number of arguments. If one element is a list and the other is a scalar, the scalar will be automatically expanded to a list with the proper number of elements. The result is the list of the results.
Examples: 
(6_7)|(4_5) == (4_7)
(5_7)|(4_6) == (4_7)
(1_2)|(2_4) == (1_4)
(3_4)|(-3_-2) == (-3_4)

Group: setList
Name: &&&&
Type: infix function
Number of left args:  variable
Number of right args:  at least 1
Supported left domain: (Complex Interval)
Supported right domain: (Complex Interval)
Priority: 6, Min Priority: 0, Max Priority: 13
Associativity: left to right
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: (listA) &&&& (listB) returns the intersection of the given setlist.
The intersection is made by the common elements without duplicates.
Examples: 
(1, 2, 3, 4, 4, 5, 6)&&&&(4, 5, 6, 7, 8) == (4, 5, 6)

Group: setList
Name: ----
Type: infix function
Number of left args:  variable
Number of right args:  at least 1
Supported left domain: (Complex Interval)
Supported right domain: (Complex Interval)
Priority: 6, Min Priority: 0, Max Priority: 13
Associativity: left to right
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: (listA) ---- (listB) returns the difference of the given setlist.
The difference is given by the elements of listA not available in listB without duplicates. Note that difference is not commutative while union and intersections are commutative. If an element of the second set does not exist in the first it is not removed neither an error is rised: (1,2) ---- (3,2,4) returns 1 although 3, 4 do not exists on the first list.
Examples: 
(1, 2, 3, 4, 4, 5, 6)----(4, 5, 6, 7, 8) == (1,2,3)
(4, 5, 6, 7, 8)----(1, 2, 3, 4, 4, 5, 6) == (7,8)

Group: setList
Name: setListExtract
Type: prefix function
Number of args: at least 1
Supported domain: (Complex Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: setListExtract (list) returns the sub list which is a proper set.
Basically a proper list set does not have any duplicate, therefore it removes them.
Examples: 
setListExtract(1, 2, 3, 4, 5, 6, 4, 5) == 1, 2, 3, 6, 4, 5

Group: setList
Name: setListSort
Type: prefix function
Number of args: at least 1
Supported domain: (Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: setListSort (list) returns an ordered list with the same elements of the given one.
It runs with the BubbleSort algorithm taken from http://www.dreamincode.net/code/snippet513.htm with a change to swap a full row in case of matrix. If the input is a matrix it order the first column, the elements in the other rows are arranged accordingly with first row. For more powerful sorting algorithm check matrixSort.
Examples: 
setListSort(1, 4, 2, 3, 5, 6) == 1, 2, 3, 4, 5, 6
setListSort((1, 4, 2, 3, 5, 6)#1,(1 .. 6)#1) == (1 .. 6)#1,(1,3,4,2,5,6)#1

Group: setList
Name: ||||
Type: infix function
Number of left args:  variable
Number of right args:  at least 1
Supported left domain: (Complex Interval)
Supported right domain: (Complex Interval)
Priority: 5, Min Priority: 0, Max Priority: 13
Associativity: left to right
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: (listA) |||| (listB) returns the union of the lists A and B.
Union means the common elements without duplicates.
Examples: 
(1, 2, 3, 4, 4, 5, 6)||||(4, 5, 6, 7, 8) == (1, 2, 3, 4, 5, 6, 7, 8)

Group: statistic
Name: statisticAverage
Type: prefix function
Number of args: at least 1
Supported domain: (Complex Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: statisticAverage (list) returns average interval among the intervals content in the list.
Examples: 
statisticAverage(1, 2, 3, 4) == 2.5

Group: statistic
Name: statisticCorrelation
Type: prefix function
Number of args: at least 1
Supported domain: Matrix: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: statisticCorrelation [matrix] returns the correlation of two column the matrix being every column an input data.
Examples: 
statisticCorrelation((1,2,4,8,5,10)#2) == 1

Group: statistic
Name: statisticCovariance
Type: prefix function
Number of args: at least 1
Supported domain: Matrix: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: statisticCovariance [matrix] returns the covariance of two column of the matrix being every column an input data.
Examples: 
statisticCovariance((1,2,3,4,5,6)#2) == 4

Group: statistic
Name: statisticDistributionNormal
Type: prefix function
Number of args: 3
Supported domain: (Interval,Interval,Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: statisticDistributionNormal (average, sdeviation, x) computes the Gauss or Normal distribution defined as 1/(sdeviation*sqrt(2*PI))*exp(-sqr((x-average)/sdeviation/2)) where m is the average, d the standard deviation and x the evaluation point
The distribution can be used together with statistiRandomList to generate random variable to be used in MonteCarlo simulation. For example to generate a Normal statistic variable a with average 1 and standard deviation 2 it is possible to write: a = statisticRandomList(plotStandard(($tmp,1,2,$x)#=$statisticDistributionNormal, 100, -9_11)). The variable a contains 8000 random valued with given probability distribution. The variable a can be used in further calculations like it was a single value. To analyze the statistical result of the calculation it is possible to use the statistic functions like statisticAverage or statisticStandardDeviation. The resul statistic distribution can be captured by statisticFrequencyBinNormalized to be used as a new distribution probability to generate new statistic variables.
Examples: 
($g, statisticRandom(-5_5), statisticRandom(1_2), $x) #= $statisticDistributionNormal; calculusIntegrate($g, -40_40) == 1

Group: statistic
Name: statisticDistributionTriangular
Type: prefix function
Number of args: 3
Supported domain: (Proper Interval,Point Interval,Point Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: statisticDistributionTriangular (interval, max, x) computes the triangular distribution defined as 1/range(i) if x is within the interval i, 0 otherwise.
The distribution can be used together with statistiRandomList to generate random variable to be used in MonteCarlo simulation. For example to generate a Normal statistic variable a with average 1 and standard deviation 2 it is possible to write: a = statisticRandomList(plotStandard(($tmp,1,2,$x)#=$statisticDistributionNormal, 100, -9_11)). The variable a contains 8000 random valued with given probability distribution. The variable a can be used in further calculations like it was a single value. To analyze the statistical result of the calculation it is possible to use the statistic functions like statisticAverage or statisticStandardDeviation. The resul statistic distribution can be captured by statisticFrequencyBinNormalized to be used as a new distribution probability to generate new statistic variables.
Examples: 
($g, statisticRandom(-5_-1) _ statisticRandom(1_5), statisticRandom(-1_1), $x) #= $statisticDistributionTriangular; calculusIntegrate($g, -10_10) == 1

Group: statistic
Name: statisticDistributionUniform
Type: prefix function
Number of args: 2
Supported domain: (Proper Interval,Proper Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: statisticDistributionUniform (interval, x) computes the uniform distribution defined as 1/range(interval) if x belongs to interval, 0 otherwise.
The distribution can be used together with statistiRandomList to generate random variable to be used in MonteCarlo simulation. For example to generate a Normal statistic variable a with average 1 and standard deviation 2 it is possible to write: a = statisticRandomList(plotStandard(($tmp,1,2,$x)#=$statisticDistributionNormal, 100, -9_11)). The variable a contains 8000 random valued with given probability distribution. The variable a can be used in further calculations like it was a single value. To analyze the statistical result of the calculation it is possible to use the statistic functions like statisticAverage or statisticStandardDeviation. The resul statistic distribution can be captured by statisticFrequencyBinNormalized to be used as a new distribution probability to generate new statistic variables.
Examples: 
($g, statisticRandom(-5_0) _ statisticRandom(1_2), $x) #= $statisticDistributionUniform; abs(calculusIntegrate($g, -5_2)-1)<0.1 == true

Group: statistic
Name: statisticFrequencyBinCumulative
Type: prefix function
Number of args: 2
Supported domain: ({Interval List of [Real Interval]} or Point Interval and Positive Interval,{Interval List of [Real Interval]})
Does not extend to list
This function is locked: cannot be changed by user
Help: statisticFrequencyBinCumulative (nOfBin, {list}) computes the smallest interval which contains all the list values, then it split that interval in the given nOfBins, then it counts the values of the list falling in each bin.
The output is a matrix form which can be used for plot window. statisticFrequencyBinCumulative requires: the number of bins and then the {sub-list} to analyze. Instead of the number of bins it is possible to provide the list of intervals that made up the bins, the only requirement it that they are monotonically increasing. In the last condition since there can be void between bins or the bins may fall outside the values the integrale may not get all the values.
Examples: 
statisticFrequencyBinCumulative(2, {1,1,1,1,2.5,2.5,3}) == [[1_2, 4],[2_3, 3]]
statisticFrequencyBinCumulative({1_2, 2_3}, {1,1,1,1,2.5,2.5,3}) == [[1_2, 4],[2_3, 3]]

Group: statistic
Name: statisticFrequencyBinNormalized
Type: prefix function
Number of args: 2
Supported domain: ({Interval List of [Real Interval]} or Point Interval and Positive Interval,{Interval List of [Real Interval]})
Does not extend to list
This function is locked: cannot be changed by user
Help: statisticFrequencyBinNormalized (nOfBin, {list}) computes the smallest interval which contains all the list values, then it split that interval in the given nOfBins, then it counts the values of the list falling in each bin, eventually normalized the result in order to get total area equal to 1.
The output is a matrix form which can be used for plot window. statisticFrequencyBinNormalized requires: the number of bins and then the {sub-list} to analyze. Instead of the number of bins it is possible to provide the list of intervals that made up the bins, the only requirement it that they are monotonically increasing. In the last condition since there can be void between bins or the bins may fall outside the values the integrale may not get all the values.
Examples: 
statisticFrequencyBinNormalized(2, {1,1,1,1,2.5,2.5,3}) == [[1_2, 4/7],[2_3, 3/7]]
statisticFrequencyBinNormalized({1_2, 2_3}, {1,1,1,1,2.5,2.5,3}) == [[1_2, 4/7],[2_3, 3/7]]

Group: statistic
Name: statisticInvertMeasure
Parameter: epson
Value: 0.01
Expected Input: Requires double value between 0.0 and 1000.0
Default: 0.01
Help: Set the maximum distance between two ys to consider them equal.

Group: statistic
Name: statisticInvertMeasure
Type: prefix function
Number of args: at least 1
Supported domain: Matrix: (Proper Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: statisticInvertMeasure [xExpectedPoint, yMeasuredInterval] where x is expected (usually a point interval) and y is measure (must be an interval) then it compute the inverse function table: [yMeasuredIntervalReduced, xExpectedPoint].
 The x does not require to be ordered. Basically the y is scanned to find the min, max and minimuminterval range. The an intergal of size range/2 goes from y min to y max. For each step it computes the average of the x values weighted with the percentage of intersection of y.
Examples: 
statisticInvertMeasure([ 4,  1_3  ],[ 6, 2_4  ],[  8 , 3.5_6  ],[ 10 , 7_8  ],[ 12, 7.5_9  ],[ 14, 8.5_11]) == [1_2,  4  ],[2_3 , 5  ],[3_3.5 ,  6  ],[ 3.5_4, 7  ],[ 4_6, 8  ],[ 7_7.5 ,10  ],[ 7.5_8 ,11  ],[8_8.5, 12  ],[ 8.5_9, 13],[ 9_11,14  ]

Group: statistic
Name: statisticMeanAbsoluteDeviation
Type: prefix function
Number of args: at least 1
Supported domain: (Complex Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: statisticMeanAbsoluteDeviation (list) returns the mean of the absolute variation between samples of the list and the mean of them.
It is an index of how much the samples are far from the mean. Usually it is ERRONEOUSLY used the standard deviation to indicate the MAD.
Examples: 
statisticMeanAbsoluteDeviation(1, 2, 3, 4) == statisticAverage(abs((1 .. 4)-statisticAverage(1 .. 4)))

Group: statistic
Name: statisticMinMax
Type: prefix function
Number of args: at least 1
Supported domain: (Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: statisticMinMax (list) returns a list containing the minimum and maximum interval found in the given list of intervals.
If statisticMinMax receives a function data (2 column matrix) return the following matrix [[xmin, min], [xmax, max]].
Examples: 
statisticMinMax(1_2, 4_5, 6_7) == 1_2, 6_7
a = plotStandard($sin, 5, 0_2*PI); statisticMinMax (a) == [[3*PI/2, -1],[PI/2, 1]]

Group: statistic
Name: statisticPercentile
Type: prefix function
Number of args: at least 1
Supported domain: (Real Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: statisticPercentile (list) returns the list with the precentile (0, 25th, 50th or median, 75th, 100th) of the given list of values.
Examples: 
statisticPercentile(5,4,3,1) == 1,2,3.5,4.5,5
statisticPercentile(5,4,3,1,2) == 1,2,3,4,5

Group: statistic
Name: statisticRandom
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: statisticRandom (interval) returns a random number contained in the given interval.
It can be useful to apply to constant list in order to get random list or matrix.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
statisticRandom(10_10) == 10

Group: statistic
Name: statisticRandomGenerator
Parameter: elementsForSimulation
Value: 8000
Expected Input: Requires integer value between 1 and 10000
Default: 8000
Help: It is also possible to set the numbero of elements to be used in simulation  (like montecarlo, random, ?=, ..).

Group: statistic
Name: statisticRandomGenerator
Parameter: seed
Value: 0
Expected Input: Requires long integer value between 0 and 9223372036854775807
Default: 0
Help: It is also possible to set the seed for the random generator, use 0 for the current time in ms. The seed is used when a new random generator is selected, so to make it active it is required to select the random generator type after setting seed.

Group: statistic
Name: statisticRandomGenerator
Parameter: type
Value: 1
Expected Input: Requires random index. Requires integer value between 1 and 4
Default: 1
Help: Sets the random generator uses the library edu.cornell.lassp.houle.RngPack version 1.1 available on edu.cornell.lassp.houle.RngPack. ... can be used to set the required random generator. Use 0 to keep the previus random generator, 1 for Mersenne twister period 2^19937-1 time 7.1s, 2 for RANLUX which is an advanced pseudo-random number generator based on the RCARRY algorithm proposed in 1991 by Marsaglia and Zaman period 10^171 time 14.7 s, 3 Ranecu is an advanced multiplicative linear congruential random number generator period 10^18 time 5.8 s, 4 RANMAR is a lagged Fibonacci generator proposed by Marsaglia and Zaman and is a good research grade generator 10^43 time 4.2 s. 

Group: statistic
Name: statisticRandomList
Type: prefix function
Number of args: at least 2
Supported domain: Matrix: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: statisticRandomList [probabilityDistribution] returns a list of random number following the given pdf.
The pdf does not require to be normalized (i.e. its integration should not be 1). The number of elements of the list is defined globally with randomgenerator function (by default it is 8000). The variables generated with this function can be used for Monte Carlo analysis.
Examples: 
pdf = [[0_1, 0.2],[1_2, 0.6], [2_3, 0.2]]; dist = statisticRandomList(pdf); diffuseCumulate('+', abs((statisticFrequencyBinNormalized(3, {dist})-pdf) :: (1_-1, 1))) < 0.1 == true

Group: statistic
Name: statisticRandomListAsDistribution
Type: prefix function
Number of args: at least 3
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: statisticRandomListAsDistribution ($funcName, param1, param2, $x, .., interval) is just a short cut for the following espression statisticRandomList(plotStandardAdaptive((defineLambdaGetName, param1, param2, $x, ..)#=$funcName, interval)).
It can be used to create a statistical variable with distribution like $funcName. The variable can be used for MonteCarlo analysis. Please note the function $temporaryFunction remains defined after the function ran, and if it was already defined, its definition is replaced.
Examples: 
a = statisticRandomListAsDistribution($statisticDistributionUniform, 0_1, $x, 0_1); statisticStandardDeviation(statisticFrequencyBinNormalized(100, {a}) :: (0_-1, 1)) < 0.2, abs(statisticAverage(a)-intervalValue(0_1))<10m, abs(statisticStandardDeviation(a)-intervalRange(0_1)/sqrt(12))<10m == true, true, true

Group: statistic
Name: statisticRegressionGeneral
Type: prefix function
Number of args: at least 1
Supported domain: Matrix: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: statisticRegressionGeneral ([columnx0, columnx1, .., columnxn, columny]) returns the coefficient of a generic linear regression (a0, a1, .., an) to get the best minimum square approximation of  (a0 * columnx0 + a1 * columnx1 + .. + an * comumnxn ) as close as possible to columny.
The initial columns are xi and the last one is y. y = b0 x0  + b1 x1 + .. For example a standard simple linear regression would be y =  b0 * 1 + b1 * xi: therefore the matrix rows will be (1 xi yi). yi is found with the least square algorithm. For a quadratic regression y = b0 + b1 xi + b2 xi^2 the rows will be (1 xi xi^2 y). Those rows can be built with an ad hoc function ($f, $t)='1, t, t^2', then the matrix will be f(x)#3,y. Using this tool it is possible to apply on several regressions like power, multi variable, logarithm.
Examples: 
xy = (1,3,4,9,5,11)#2;$xr = (xy :: (0_-1, 0));$yr = (xy :: (0_-1, 1)); ($reg, $x)='1, x'; statisticRegressionGeneral ((reg(xr))#2,yr)  == statisticRegressionLinear (xy)

Group: statistic
Name: statisticRegressionLinear
Type: prefix function
Number of args: at least 1
Supported domain: Matrix: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: statisticRegressionLinear [columnx, columny] returns the (a, b) of the line columny = a + b * columnx which is closer to the given points as per last squares.
Examples: 
statisticRegressionLinear((1,3,4,9,5,11)#2) == 1,2

Group: statistic
Name: statisticStandardDeviation
Type: prefix function
Number of args: at least 1
Supported domain: (Complex Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: statisticStandardDeviation (list) returns the square root of the average of the difference among the list of value and its average value squared.
It computes the average from a sample (dividing by n-1).
Examples: 
statisticStandardDeviation(1,1,1) == 0
statisticStandardDeviation(1,2,1,2) == sqrt(1/3)

Group: statistic
Name: statisticStandardDeviationPopulation
Type: prefix function
Number of args: at least 1
Supported domain: (Complex Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: statisticStandardDeviationPopulation (list) returns the square root of the average of the difference among the list of value and its average value squared.
It computes the average from a population (dividing by n).
Examples: 
statisticStandardDeviationPopulation(1,1,1) == 0
statisticStandardDeviationPopulation(1,2,1,2) == sqrt(1/4)

Group: system
Name: answerGet
Type: prefix function
Number of args: at least 1
Supported domain: (Integer Interval)
Does not extend to list
This function is locked: cannot be changed by user
Help: answerGet (answerInd1, answerInd2, answerInt1Begin_answerInt1End, ..) return previous ICE answers.
It gets the list of answer to return: 1, 2, 3 would return the list made by answer1, answer2, answer3. If an interval is provided 1_4 all the answer between 1 and 4 will be returned. Negative number goes from the back of the list: -1 is lastAnswer, -2 the answer befor and so on.

Group: system
Name: systemQuit
Type: prefix function
Number of args: 0
Supported domain:  everything
Automatically extends to list
This function is locked: cannot be changed by user
Help: systemQuit () exits from ICE.
It drastically close the JVM regardless of the status of the history, etc.. So no question about not-saved files will be asked.

Group: system
Name: systemSetupGetParameter
Type: prefix function
Number of args: at least 1
Supported domain: (Literal)
Does not extend to list
This function is locked: cannot be changed by user
Help: systemSetupGetParameter ($symbol1, $parameter1, $parametern) show the parameter1 up to parametern values.
If '' is provided it returns all the symbols available for settings. If only the symbol is provided systemSetupGetParameter returns all the changable parameters associated with it. Those parameters can be changed with systemSetupSetParameter. It is possible to use just the beginning characters as far as the matching is unique.
Examples: 
systemSetupGetParameter('functionScanLinear') == 'functionScanLinear -> samples = 10000'
systemSetupGetParameter('functionScanLinear','samples') == 'functionScanLinear -> samples = 10000'

Group: system
Name: systemSetupSetParameter
Type: prefix function
Number of args: at least 3
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: systemSetupSetParameter ('symbol', 'param1', val1, .. , 'paramN', valN) set the parameters of the given symbol.
Some symbol (usually function) in ICE has a static setting (sead parameter). Usually a symbol is a function and parameters are its settingsup the working parameters for a prefix function. It is possible to use just the beginning characters as far as the matching is unique for symbol and parameter. If the parameter is 'DEFAULT' it is set at the value ICE sets at startup.
Examples: 
; listSize functionScanIntervalSplitRandom (1_19) == 1000
systemSetupSetParameter ($functionScanIntervalSplitRandom, 'samples', 19); listSize functionScanIntervalSplitRandom (1_19) == 19
a=5_10;systemSetupSetParameter($intervalALL, 'avoidRoundings', 0),b=(a-intervalDual(a)==0,sqrt(a^2)==a),systemSetupSetParameter($intervalALL, 'avoidRoundings', 1),c=(a-intervalDual(a)==0,sqrt(a^2)==a);b,c == 0,0,1,1
a = statisticRandom( listClone (10, 0_1)); b = statisticRandom( listClone (10, 0_1)); diffuseCumulate ('&&', a == b) == false
systemSetupSetParameter($statisticRandomGenerator, 'seed', 1234), systemSetupSetParameter($statisticRandomGenerator, 'type', 1); a = statisticRandom( listClone (10, 0_1)); systemSetupSetParameter($statisticRandomGenerator, 'type', 1); b = statisticRandom( listClone (10, 0_1)); diffuseCumulate ('&&', a == b) == true
systemSetupSetParameter('defineALL', 'currentGroup', 'pippo'), a=5, systemSetupSetParameter('defineALL', 'currentGroup', 'DEFAULT');pippoa == 5

Group: system
Name: systemUseGroup
Type: prefix function
Number of args: 1
Supported domain: (Literal)
Automatically extends to list
This function is locked: cannot be changed by user
Help: systemUseGroup ('group') is able to load the functions contained in the given group.
It returns the group name loaded if any. A group cannot be loaded twice, if you try it will not be loaded the second time. It is possible select any of the following group: [arithmetic, calculus, compare, complex, conditional, constant, convert, decibel, define, diffuse, engineer, equation, file, flowControl, fourier, functionScan, hyperbolic, information, integer, interval, list, literal, logarithm, logic, matrix, measurementUnit, multilineExpression, optimization, plot, polynomial, power, program, reactiveExpression, setInterval, setList, statistic, system, trigonometry, vector] or a super group. A super group is all upper case and is a short cut to load several groups. For details on the functions available for each group see features command. It is possible to load a group of groups calling systemUseGroup with the following names: BASE (the basic groups like arithmetic, power, trigonometry, etc.) and it is loaded automatically at startup. ENGINEER to load all the groups useful for engineer stuff, PROGRAM to load all the groups used for advanced programming, ALL to load all the groups available. The following list show the exact groups loaded for a given group: Super Group BASE composed by groups: arithmetic, compare, complex, define, diffuse, information, interval, list, logarithm, power, reactiveExpression, system, trigonometry; Super Group ENGINEER composed by groups: constant, convert, decibel, engineer, equation, fourier, optimization, plot; Super Group PROGRAM composed by groups: conditional, flowControl, literal, logic, multilineExpression, program; Super Group ALL composed by groups: arithmetic, calculus, compare, complex, conditional, constant, convert, decibel, define, diffuse, engineer, equation, file, flowControl, fourier, functionScan, hyperbolic, information, integer, interval, list, literal, logarithm, logic, matrix, measurementUnit, multilineExpression, optimization, plot, polynomial, power, program, reactiveExpression, setInterval, setList, statistic, system, trigonometry, vector; It is also posible just use the beginning chars of the group name as far as it is unique. It is also possible loading groups from third parth (not compiled together with ICE), in that case the group name should present the full path like for example uni.edu.ice.fuzzy in this case the last name of the path is the same of the groups, therefore in the previous example all the functions are expected to begin by fuzzy.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.

Group: trigonometry
Name: PI
Type: variable
This variable is locked: cannot be changed by user
Help: PI returns the ratio between a circumference and its diameter.

Group: trigonometry
Name: arcCos
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: arcCos (interval) computes the inverse cos of the given interval included in -1, 1.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
arcCos(1) == 0
arcCos(0) == PI/2

Group: trigonometry
Name: arcSin
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: arcSin (interval) computes the inverse sin of the interval included in -1, 1.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
arcSin(1) == PI/2
arcSin(0) == 0

Group: trigonometry
Name: arcTan
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: arcTan (interval) computes the inverse tan of the given interval.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
arcTan(0) == 0
arcTan(1) == PI/4

Group: trigonometry
Name: cos
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: cos (interval) computes the cosine of the given interval.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
cos(0) == 1
cos(PI/2) == 0

Group: trigonometry
Name: sin
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: sin (interval) computes the sin of the given interval.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
sin(PI/2) == 1
sin(0) == 0

Group: trigonometry
Name: tan
Type: prefix function
Number of args: 1
Supported domain: (Real Interval)
Automatically extends to list
This function is locked: cannot be changed by user
Help: tan (interval) computes the tan of the given interval.
If the argument is a list the function is automatically applied to all the elements of the list providing as result the list of the results.
Examples: 
tan(0) == 0
tan(PI/4) == 1

Group: vector
Name: *.
Type: infix function
Number of left args:  variable
Number of right args:  at least 1
Supported left domain: (everything)
Supported right domain: (everything)
Priority: 10, Min Priority: 0, Max Priority: 13
Associativity: left to right
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: (vectorA) *. (vectorB) multiply the vectorA represented by its list for the vectorB represented by its list.
It sum up the product of the respective elements as per Kaucher arithmetic.  This function can be also applied to a set of sublist of ({vectL1}, {vectL2}, ..) *. ({vectR1}, {vectR2}, ..)
Examples: 
((1,2,3,4))*.((2,3,4,5)) == (2+6+12+20)

Group: vector
Name: *:
Type: infix function
Number of left args:  variable
Number of right args:  at least 1
Supported left domain: (everything)
Supported right domain: (everything)
Priority: 10, Min Priority: 0, Max Priority: 13
Associativity: left to right
Does not extend scalar input to list
This function is locked: cannot be changed by user
Help: (vectorA) *: (vectorB) compute the vectorial product of the vectors A and B represented by their lists.
The product is defined only for 3 dimensions vectors. This function can be also applied to a set of sublist of ({vectL1}, {vectL2}, ..) *: ({vectR1}, {vectR2}, ..)
Examples: 
(v1 = (1,2,3), v2 = (4,5,6); v1 *: v2 == -(v2 *: v1)) == (true,true,true)
(a = statisticRandom (listClone(3, 0_10)); b = statisticRandom (listClone(3, 0_10)); c = statisticRandom (listClone(3, 0_10)); abs( a *. (b *: c) - b *. (c *: a)) <0.001, abs(b *. (c *: a) - c *. (a *: b)) < 0.001) == (true, true)

Group: vector
Name: vectorCurl
Type: prefix function
Number of args: at least 1
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: vectorCurl ($f, x0, .., xn) returns the vector product (also known as curl) of the vector function f applied to the given intervals.
The input interval are used to compute the incremental ratio. This function can be also applied to a set of sublist of ({matrix1}, {matrix2}, ..)
Examples: 
vectorCurl(defineLambdaFunction('$y,-$x,0*$z'), 1_2,1_2,1_2) == 0,0,-2
vectorCurl(defineLambdaFunction('0*$y,-($x^2),0*$z'), 1_2,1_2,1_2) == 0,0,-2*1.5

Group: vector
Name: vectorDivergence
Type: prefix function
Number of args: at least 1
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: vectorDivergence ($f, x0, .., xn) returns the divergence of the scalar function f applied to the given intervals.
The input interval are used to compute the incremental ratio. This function can be also applied to a set of sublist of ({matrix1}, {matrix2}, ..)
Examples: 
vectorDivergence(defineLambdaFunction('2*$x+$y,$x+3*$y'), 1_2,3_4) == 2+3
vectorDivergence(defineLambdaFunction('2*$x*$y,$x*3*$y'), 1_2,3_4) == 2*3.5+3*1.5

Group: vector
Name: vectorGradient
Type: prefix function
Number of args: at least 1
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: vectorGradient ($f, x0, .., xn) returns the gradient of the scalar function f applied to the given interval vector space x0, .., xn.
The input intervals are used to compute the incremental ratio. This function can be also applied to a set of sublist of ({matrix1}, {matrix2}, ..)
Examples: 
vectorGradient(defineLambdaFunction('2*$x+3*$y'), 1_2,3_4) == 2,3
vectorGradient(defineLambdaFunction('2*$x*$y'), 1_2,3_4) == 2*3.5,2*1.5

Group: vector
Name: vectorModule
Type: prefix function
Number of args: at least 1
Supported domain: (everything)
Does not extend to list
This function is locked: cannot be changed by user
Help: vectorModule (vector) returns the module of the given vector.
It is the scalar prodct to itself. This function can be also applied to a set of sublist of ({vector1}, {vector2}, ..)
Examples: 
vectorModule((1,2,3,4)) == sqrt(1+4+9+16)
